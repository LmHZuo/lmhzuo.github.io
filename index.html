<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#33363b">
    <meta name="msapplication-TileColor" content="#33363b">
    
    
    
    <meta name="keywords" content="Life, ARIA, Hexo">
    
    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    
    
    <link rel="icon" type="image/png" sizes="192x192" href="/favicons/android-chrome-192x192.png">
    
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
    
    
    <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#33363b">
    
    
    <link rel="manifest" href="/favicons/site.webmanifest">
    
    
    <meta name="msapplication-config" content="/favicons/browserconfig.xml">
    
    
    <link rel="alternate" href="/atom.xml" title="程序猿的日常" type="application/atom+xml" />
    
    
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico">
    
    
    <link rel="stylesheet" type="text/css" href="/css/normalize.css">
    <link rel="stylesheet" type="text/css" href="/css/index.css">
    
    <link rel="stylesheet" type="text/css" href="/css/sidebar.css">
    
    
    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <link rel="stylesheet" type="text/css" href="/css/atom-one-dark.css">
    <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css">
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script defer type="text/javascript" src="/js/util.js"></script>
    <script defer type="text/javascript" src="/js/scrollspy.js"></script>
    <script defer type="text/javascript" src="/js/fontawesome-all.min.js"></script>
    <script defer type="text/javascript" src="/js/lightgallery.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-fullscreen.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-hash.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-pager.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-thumbnail.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-zoom.min.js"></script>
    
    <script defer src="/js/busuanzi.pure.mini.js"></script>
    
    
    <script defer type="text/javascript" src="/js/search.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var searchPath = "search.xml";
      if (searchPath.length === 0) {
        searchPath = "search.xml";
      }
      var path = "/" + searchPath;
      searchFunc(path, "search-input", "search-result");
    });
    </script>
    
    
    <script defer type="text/javascript" src="/js/index.js"></script>
    
    <script defer type="text/javascript" src="/js/custom.js"></script>
    <title>程序猿的日常</title>
  </head>
  <body itemscope itemtype="http://schema.org/WebPage" lang="default"  data-spy="scroll" data-target=".list-group">
    
<header id="header" class="header" style="background: #33363b;">
  <div class="container">
    <div class="header-container">
      <div class="header-title">
        <h1 class="title"><a href="/">程序猿的日常</a></h1>
        <h2 class="subtitle"></h2>
      </div>
      <div class="logo">
        <img src="/images/ARIA_logo.png" alt="logo">
      </div>
    </div>
    
<nav id="nav" class="nav">
  <a id="nav-toggle" class="nav-toggle"><i class="fas fa-bars"></i></a>
  <ul id="menu">
    
    <li><a href="/" class="current">首页</a></li>
    
    <li><a href="/archives/">Archives</a></li>
    
  </ul>
</nav>


  </div>
</header>


    <main id="main" class="main">
      <div class="container">
        <div class="main-container">
          <div class="content">
            

<div id="index" class="index">
  
  <article class="index-post card" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/26/docker/docker_dbe_/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="龙门小左">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="程序猿的日常">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2018/06/26/docker/docker_dbe_/" itemprop="url">docker  一台虚拟机安装部署分布式web 前后端分离集群</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2018-06-26T10:00:00+08:00">2018-06-26 10:00:00</time></span>
        </span>
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="docker-安装部署分布式web-前后端分离集群"><a href="#docker-安装部署分布式web-前后端分离集群" class="headerlink" title="docker  安装部署分布式web 前后端分离集群"></a>docker  安装部署分布式web 前后端分离集群</h1><table>
<thead>
<tr>
<th style="text-align:center">版本</th>
<th style="text-align:center">作者</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2018.06.29</td>
<td style="text-align:center">huangzuo</td>
<td style="text-align:center">首次发布</td>
</tr>
</tbody>
</table>
<h3 id="学习内容简介"><a href="#学习内容简介" class="headerlink" title="学习内容简介"></a>学习内容简介</h3><p>   相关课程指令脚本可以在百度云下载<br><a href="https://pan.baidu.com/s/15aVny_MRi0AQBQJE7myUOg" target="_blank" rel="noopener">https://pan.baidu.com/s/15aVny_MRi0AQBQJE7myUOg</a> 密码：j413</p>
<pre><code>本章节主要大概介绍如何使用docker虚拟机，部署分布式web 前后端分离集群，包过
1、人人网开源前后端分离项目
2、配置docker加载器
3、安装mysql pxc集群
4、安装redis 集群
5、部署后端的项目
6、安装ngxin 集群
7、前端项目部署与负载均衡
</code></pre><h3 id="人人网开源前后端分离项目"><a href="#人人网开源前后端分离项目" class="headerlink" title="人人网开源前后端分离项目"></a>人人网开源前后端分离项目</h3><p>地址: <a href="http://www.renren.io/,项目renren-fast" target="_blank" rel="noopener">http://www.renren.io/,项目renren-fast</a> </p>
<p>功能:<br><img src="images/renren.jpg" alt=""></p>
<h3 id="配置docker加载器"><a href="#配置docker加载器" class="headerlink" title="配置docker加载器"></a>配置docker加载器</h3><p>由于docker仓库在国外，需要配置国内远程镜像加速下载速度<br>访问地址:<a href="https://www.daocloud.io/" target="_blank" rel="noopener">https://www.daocloud.io/</a> 注册账号<br>执行对应的语句<br><img src="images/docker1.jpg" alt=""></p>
<h3 id="几个重要的docker指令"><a href="#几个重要的docker指令" class="headerlink" title="几个重要的docker指令"></a>几个重要的docker指令</h3><h4 id="查看容器运行日志"><a href="#查看容器运行日志" class="headerlink" title="查看容器运行日志"></a>查看容器运行日志</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f -t --tail 10 h1</span><br><span class="line"></span><br><span class="line">docker logs h1</span><br></pre></td></tr></table></figure>
<p>h1:容器名称</p>
<p>10:最近10行</p>
<h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it h1 bash</span><br></pre></td></tr></table></figure>
<h3 id="mysql-pxc集群安装"><a href="#mysql-pxc集群安装" class="headerlink" title="mysql pxc集群安装"></a>mysql pxc集群安装</h3><h4 id="下载pxc"><a href="#下载pxc" class="headerlink" title="下载pxc"></a>下载pxc</h4><p>访问网站<a href="https://hub.docker.com/r/percona/percona-xtradb-cluster/" target="_blank" rel="noopener">https://hub.docker.com/r/percona/percona-xtradb-cluster/</a> 里面有关percona/percona-xtradb-cluster集群安装相关描述<br>xshell 执行下面代码，下载镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull percona/percona-xtradb-cluster</span><br></pre></td></tr></table></figure></p>
<p>修改容器名称，删除原来的容器</p>
<p>修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag docker.io/percona-xtradb-cluster pxc</span><br></pre></td></tr></table></figure></p>
<p>删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm docker.io/percona-xtradb-cluster</span><br></pre></td></tr></table></figure></p>
<h4 id="安装mysql集群"><a href="#安装mysql集群" class="headerlink" title="安装mysql集群"></a>安装mysql集群</h4><p>在一台服务器安装5个pxc容器，即5台数据库，修改其中一台数据库的信息，其他四台也会同步修改</p>
<h5 id="设置网段"><a href="#设置网段" class="headerlink" title="设置网段"></a>设置网段</h5><p>处于安全考虑，需要给PXC集群实例创建docker内部网络<br>创建<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create net1</span><br></pre></td></tr></table></figure></p>
<p>查看<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect net1</span><br></pre></td></tr></table></figure></p>
<p>删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network rm net1</span><br></pre></td></tr></table></figure></p>
<p>默认的网段是172.17.0.0 ，可以设置自己的网段<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --subnet=172.18.0.0/24 net1</span><br></pre></td></tr></table></figure></p>
<h5 id="创建docker卷"><a href="#创建docker卷" class="headerlink" title="创建docker卷"></a>创建docker卷</h5><p>容器是一个独立的空间，可编辑、删除等操作，为了保存容器的数据，需要把数据的路径映射到宿主机目录下。即把容器中的数据保存在宿主机中，就算容器被删数据还是保留下来</p>
<p>创建docker卷语句<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create v1</span><br></pre></td></tr></table></figure></p>
<p>查看docker卷，可知道在宿主机的目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect v1</span><br></pre></td></tr></table></figure></p>
<p><img src="images/docker2.jpg" alt=""><br>删除docker卷<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm v1</span><br></pre></td></tr></table></figure></p>
<h5 id="创建pxc容器集群"><a href="#创建pxc容器集群" class="headerlink" title="创建pxc容器集群"></a>创建pxc容器集群</h5><p>创建pxc容器集群：第一个pxc容器和其他容器不一样</p>
<h6 id="创建第一个pxc容器"><a href="#创建第一个pxc容器" class="headerlink" title="创建第一个pxc容器"></a>创建第一个pxc容器</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=root -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=root -v v1:/var/lib/mysql -v backup:/data --privileged --name=node1 --net=net1 --ip 172.18.0.2 pxc</span><br></pre></td></tr></table></figure>
<p>3307:3306:3307是宿主机端口，3306为容器mysql端口，为了在外面能访问到容器mysql，需要把端口映射到宿主机上</p>
<p>1、MYSQL_ROOT_PASSWORD=root：设置mysql 的root账户密码</p>
<p>2、CLUSTER_NAME=PXC:集群名称</p>
<p>3、XTRABACKUP_PASSWORD=root:mysql 之间通讯的密码</p>
<p>4、-v v1:/var/lib/mysql -v backup:/data :v1是docker卷,映射宿主机docker卷和容器的目录，每一个容器一个docker卷</p>
<p>5、–privileged:赋予容器修改宿主机目录文件的权限</p>
<p>6、–name=node1:容器名称</p>
<p>7、–net=net1 –ip 172.18.0.2:网络ip地址</p>
<p>8、pxc:镜像名称</p>
<h6 id="创建其他pxc容器"><a href="#创建其他pxc容器" class="headerlink" title="创建其他pxc容器"></a>创建其他pxc容器</h6><p>创建其他容器和第一个容器有所不同，主要添加CLUSTER_JOIN=node1 ，意思是和node1（第一个容器）容器同步数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3308:3306 -e MYSQL_ROOT_PASSWORD=root -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=root  -e  CLUSTER_JOIN=node1 -v v2:/var/lib/mysql -v backup:/data --privileged --name=node2 --net=net1 --ip 172.18.0.3 pxc</span><br><span class="line"></span><br><span class="line">docker run -d -p 3309:3306 -e MYSQL_ROOT_PASSWORD=root -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=root  -e  CLUSTER_JOIN=node1 -v v3:/var/lib/mysql -v backup:/data --privileged --name=node3 --net=net1 --ip 172.18.0.4 pxc</span><br><span class="line"></span><br><span class="line">docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=root -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=root  -e  CLUSTER_JOIN=node1 -v v4:/var/lib/mysql -v backup:/data --privileged --name=node4 --net=net1 --ip 172.18.0.5 pxc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run -d -p 3311:3306 -e MYSQL_ROOT_PASSWORD=root -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=root  -e  CLUSTER_JOIN=node1 -v v5:/var/lib/mysql -v backup:/data --privileged --name=node5 --net=net1 --ip 172.18.0.6 pxc</span><br></pre></td></tr></table></figure>
<p>注意事项<br>1、3308:3306:3308宿主机的端口不能相同，每台映射到宿主机的端口都不一样</p>
<p>2、 CLUSTER_JOIN=node1:添加关联第一台容器</p>
<p>3、 -v v2:/var/lib/mysql：v2是docker卷,每台容器docker卷都不一样</p>
<p>4、–name=node2:每台容器名称都不一样</p>
<p>5、–net=net1 –ip 172.18.0.3:每台容器ip地址不一样</p>
<h5 id="测试集群"><a href="#测试集群" class="headerlink" title="测试集群"></a>测试集群</h5><p>pxc集群安装完，使用navicat连接数据库测试，注意连接对应的映射宿主机端口号，只要修改其中一台数据库的数据，其他数据库也会同步发生变化<br><img src="images/docker4.jpg" alt=""></p>
<h3 id="数据库负载均衡"><a href="#数据库负载均衡" class="headerlink" title="数据库负载均衡"></a>数据库负载均衡</h3><h4 id="负载均衡的必要性"><a href="#负载均衡的必要性" class="headerlink" title="负载均衡的必要性"></a>负载均衡的必要性</h4><p>pxc集群有多台数据库，如何能做到用户均匀访问不同数据库，提高网站访问并发量和性能、高可用？？</p>
<p><img src="images/docker5.jpg" alt=""></p>
<h4 id="Haproxy中间件做负载均衡"><a href="#Haproxy中间件做负载均衡" class="headerlink" title="Haproxy中间件做负载均衡"></a>Haproxy中间件做负载均衡</h4><p>haproxy 只做转发，均匀转发访问到不同数据库</p>
<p><img src="images/docker6.jpg" alt=""></p>
<h4 id="中间件比较"><a href="#中间件比较" class="headerlink" title="中间件比较"></a>中间件比较</h4><p><img src="images/docker7.jpg" alt=""></p>
<h4 id="docker安装Haproxy镜像"><a href="#docker安装Haproxy镜像" class="headerlink" title="docker安装Haproxy镜像"></a>docker安装Haproxy镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull haproxy</span><br></pre></td></tr></table></figure>
<h4 id="设置Haproxy配置文件"><a href="#设置Haproxy配置文件" class="headerlink" title="设置Haproxy配置文件"></a>设置Haproxy配置文件</h4><p>在宿主机上创建Haproxy 配置文件，haproxy.cfg文件在百度云相关指令上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch /home/soft/haproxy.cfg</span><br></pre></td></tr></table></figure>
<p>通过映射方式到haproxy容器目录中，haproxy.cfg详情需要参考网站<a href="https://zhangge.net/5125.html" target="_blank" rel="noopener">https://zhangge.net/5125.html</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">	<span class="comment">#工作目录</span></span><br><span class="line">	chroot /usr/<span class="built_in">local</span>/etc/haproxy</span><br><span class="line">	<span class="comment">#日志文件，使用rsyslog服务中local5日志设备（/var/log/local5），等级info</span></span><br><span class="line">	<span class="built_in">log</span> 127.0.0.1 local5 info</span><br><span class="line">	<span class="comment">#守护进程运行</span></span><br><span class="line">	daemon</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">	<span class="built_in">log</span>	global</span><br><span class="line">	mode	http</span><br><span class="line">	<span class="comment">#日志格式</span></span><br><span class="line">	option	httplog</span><br><span class="line">	<span class="comment">#日志中不记录负载均衡的心跳检测记录</span></span><br><span class="line">	option	dontlognull</span><br><span class="line">    <span class="comment">#连接超时（毫秒）</span></span><br><span class="line">	timeout connect 5000</span><br><span class="line">    <span class="comment">#客户端超时（毫秒）</span></span><br><span class="line">	timeout client  50000</span><br><span class="line">	<span class="comment">#服务器超时（毫秒）</span></span><br><span class="line">    timeout server  50000</span><br><span class="line"></span><br><span class="line"><span class="comment">#监控界面	</span></span><br><span class="line">listen  admin_stats</span><br><span class="line">	<span class="comment">#监控界面的访问的IP和端口</span></span><br><span class="line">	<span class="built_in">bind</span>  0.0.0.0:8888</span><br><span class="line">	<span class="comment">#访问协议</span></span><br><span class="line">    mode        http</span><br><span class="line">	<span class="comment">#URI相对地址</span></span><br><span class="line">    stats uri   /dbs</span><br><span class="line">	<span class="comment">#统计报告格式</span></span><br><span class="line">    stats realm     Global\ statistics</span><br><span class="line">	<span class="comment">#登陆帐户信息</span></span><br><span class="line">    stats auth  admin:admin</span><br><span class="line"><span class="comment">#数据库负载均衡</span></span><br><span class="line">listen  proxy-mysql</span><br><span class="line">	<span class="comment">#访问的IP和端口</span></span><br><span class="line">	<span class="built_in">bind</span>  0.0.0.0:3306  </span><br><span class="line">    <span class="comment">#网络协议</span></span><br><span class="line">	mode  tcp</span><br><span class="line">	<span class="comment">#负载均衡算法（轮询算法）</span></span><br><span class="line">	<span class="comment">#轮询算法：roundrobin</span></span><br><span class="line">	<span class="comment">#权重算法：static-rr</span></span><br><span class="line">	<span class="comment">#最少连接算法：leastconn</span></span><br><span class="line">	<span class="comment">#请求源IP算法：source </span></span><br><span class="line">    balance  roundrobin</span><br><span class="line">	<span class="comment">#日志格式</span></span><br><span class="line">    option  tcplog</span><br><span class="line">	<span class="comment">#在MySQL中创建一个没有权限的haproxy用户，密码为空。Haproxy使用这个账户对MySQL数据库心跳检测</span></span><br><span class="line">    option  mysql-check user haproxy</span><br><span class="line">    server  MySQL_1 172.18.0.2:3306 check weight 1 maxconn 2000  </span><br><span class="line">    server  MySQL_2 172.18.0.3:3306 check weight 1 maxconn 2000  </span><br><span class="line">	server  MySQL_3 172.18.0.4:3306 check weight 1 maxconn 2000 </span><br><span class="line">	server  MySQL_4 172.18.0.5:3306 check weight 1 maxconn 2000</span><br><span class="line">	server  MySQL_5 172.18.0.6:3306 check weight 1 maxconn 2000</span><br><span class="line">	<span class="comment">#使用keepalive检测死链</span></span><br><span class="line">    option  tcpka</span><br></pre></td></tr></table></figure></p>
<p>主要是关注下面和数据库有关的配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">listen  proxy-mysql</span><br><span class="line">	<span class="comment">#访问的IP和端口</span></span><br><span class="line">	<span class="built_in">bind</span>  0.0.0.0:3306  </span><br><span class="line">    <span class="comment">#网络协议</span></span><br><span class="line">	mode  tcp</span><br><span class="line">	<span class="comment">#负载均衡算法（轮询算法）</span></span><br><span class="line">	<span class="comment">#轮询算法：roundrobin</span></span><br><span class="line">	<span class="comment">#权重算法：static-rr</span></span><br><span class="line">	<span class="comment">#最少连接算法：leastconn</span></span><br><span class="line">	<span class="comment">#请求源IP算法：source </span></span><br><span class="line">    balance  roundrobin</span><br><span class="line">	<span class="comment">#日志格式</span></span><br><span class="line">    option  tcplog</span><br><span class="line">	<span class="comment">#在MySQL中创建一个没有权限的haproxy用户，密码为空。Haproxy使用这个账户对MySQL数据库心跳检测</span></span><br><span class="line">    option  mysql-check user haproxy</span><br><span class="line">    server  MySQL_1 172.18.0.2:3306 check weight 1 maxconn 2000  </span><br><span class="line">    server  MySQL_2 172.18.0.3:3306 check weight 1 maxconn 2000  </span><br><span class="line">	server  MySQL_3 172.18.0.4:3306 check weight 1 maxconn 2000 </span><br><span class="line">	server  MySQL_4 172.18.0.5:3306 check weight 1 maxconn 2000</span><br><span class="line">	server  MySQL_5 172.18.0.6:3306 check weight 1 maxconn 2000</span><br><span class="line">	<span class="comment">#使用keepalive检测死链</span></span><br></pre></td></tr></table></figure></p>
<p>bind  0.0.0.0:3306:表示所有的ip地址都能访问数据库的3306端口</p>
<p>balance  roundrobin:负载均衡分发的请求算法</p>
<p>option  mysql-check user haproxy:需要检测haproxy 和数据库直接的连接，在MySQL中创建一个没有权限的haproxy用户，密码为空。Haproxy使用这个账户对MySQL数据库心跳检测</p>
<p>server  MySQL_1 172.18.0.2:3306 check weight 1 maxconn 2000  :MySQL数据库心跳检测</p>
<h4 id="创建mysql没有权限的haproxy用户，密码为空"><a href="#创建mysql没有权限的haproxy用户，密码为空" class="headerlink" title="创建mysql没有权限的haproxy用户，密码为空"></a>创建mysql没有权限的haproxy用户，密码为空</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user <span class="string">'haproxy'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">''</span>;</span><br></pre></td></tr></table></figure>
<h4 id="创建Haproxy容器"><a href="#创建Haproxy容器" class="headerlink" title="创建Haproxy容器"></a>创建Haproxy容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建第1个Haproxy负载均衡服务器</span></span><br><span class="line">docker run -it -d -p 4001:8888 -p 4002:3306 -v /home/soft/haproxy:/usr/<span class="built_in">local</span>/etc/haproxy --name h1 --privileged --net=net1 --ip 172.18.0.7 haproxy</span><br><span class="line"><span class="comment">#进入h1容器，启动Haproxy</span></span><br><span class="line">docker <span class="built_in">exec</span> -it h1 bash</span><br><span class="line">haproxy -f /usr/<span class="built_in">local</span>/etc/haproxy/haproxy.cfg</span><br><span class="line"><span class="comment">#创建第2个Haproxy负载均衡服务器</span></span><br><span class="line">docker run -it -d -p 4003:8888 -p 4004:3306 -v /home/soft/haproxy:/usr/<span class="built_in">local</span>/etc/haproxy --name h2 --privileged --net=net1 --ip 172.18.0.8 haproxy</span><br><span class="line"><span class="comment">#进入h2容器，启动Haproxy</span></span><br><span class="line">docker <span class="built_in">exec</span> -it h2 bash</span><br><span class="line">haproxy -f /usr/<span class="built_in">local</span>/etc/haproxy/haproxy.cfg</span><br></pre></td></tr></table></figure>
<p>访问haproxy 第一个容器页面，账户密码在haproxy.cfg里面-登陆帐户信息<br>stats auth  admin:admin，我设置了admin/admin<br><a href="http://192.168.157.129:4001/dbs" target="_blank" rel="noopener">http://192.168.157.129:4001/dbs</a></p>
<p><img src="images/docker8.jpg" alt=""></p>
<p>在 navicat新建数据库连接h1， 端口号是上面对应的宿主机端口(h1是4002)和ip地址，账号密码是数据库账号密码，新增数据可以看到在node1到node5都有了数据，说明配置成功</p>
<p><img src="images/docker9.jpg" alt=""></p>
<h4 id="Haproxy高可用，创建多个haproxy"><a href="#Haproxy高可用，创建多个haproxy" class="headerlink" title="Haproxy高可用，创建多个haproxy"></a>Haproxy高可用，创建多个haproxy</h4><p>  单节点的haproxy没有高可用性能，单个haproxy挂了，整个服务就挂了<br>  <img src="images/docker10.jpg" alt=""><br>  多节点haproxy安装需要用到Keepalived，多节点会争抢虚拟ip，抢到的节点作为主节点运行，其他节点作为备份，节点之间发送心跳检测，当主节点挂了，其他备份节点会争抢成为主节点，实现高可用<br>    <img src="images/docker11.jpg" alt=""><br>  多节点haproxy方案<br>    <img src="images/docker12.jpg" alt=""></p>
<h4 id="Haproxy容器内安装Keepalived，设置虚拟IP"><a href="#Haproxy容器内安装Keepalived，设置虚拟IP" class="headerlink" title="Haproxy容器内安装Keepalived，设置虚拟IP"></a>Haproxy容器内安装Keepalived，设置虚拟IP</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入h1容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it h1 bash</span><br><span class="line"><span class="comment">#更新软件包</span></span><br><span class="line">apt-get update</span><br><span class="line"><span class="comment">#安装VIM</span></span><br><span class="line">apt-get install vim</span><br><span class="line"><span class="comment">#安装Keepalived</span></span><br><span class="line">apt-get install keepalived</span><br><span class="line"><span class="comment">#编辑Keepalived配置文件（参考下方配置文件）</span></span><br><span class="line">vim /etc/keepalived/keepalived.conf</span><br><span class="line"><span class="comment">#启动Keepalived</span></span><br><span class="line">service keepalived start</span><br><span class="line"><span class="comment">#宿主机执行ping命令</span></span><br><span class="line">ping 172.18.0.201</span><br></pre></td></tr></table></figure>
<p>keepalived.conf 配置文件 争抢虚拟IP<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vrrp_instance  VI_1 &#123;</span><br><span class="line">    state  MASTER</span><br><span class="line">    interface  eth0</span><br><span class="line">    virtual_router_id  51</span><br><span class="line">    priority  100</span><br><span class="line">    advert_int  1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type  PASS</span><br><span class="line">        auth_pass  123456</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        172.18.0.201</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>配置文件解析<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">VI_1:配置信息的名字，可以修改</span><br><span class="line"></span><br><span class="line">state  MASTER:Keepalived节点身份信息-MASTER主服务（可以多个），BACKUP备服务器（可以多个），节点启动时主服务抢占虚拟IP,备用服务器不会抢占IP</span><br><span class="line"></span><br><span class="line">interface  eth0:网卡设置，定义的虚拟IP要设置在那个网卡里面，eth0是docker虚拟机的网卡，宿主机能访问，局域网不能访问，局域网要想访问，需要在宿主机上把eth0网卡映射到局域网上某个虚拟ip上，所以宿主机也需要安装keepalived</span><br><span class="line"></span><br><span class="line">virtual_router_id  51:给Keepalived集群组起ID-虚拟路由标识，MASTER和BACKUPB的虚拟路由标识必须一致，标识可以是2~255</span><br><span class="line"></span><br><span class="line">priority  100:权重，值越大争抢到虚拟IP几率越大</span><br><span class="line"></span><br><span class="line">advert_int  1:心跳检测，MASTER和BACKUPB节点之间同步检测时间间隔，单位秒，1每一秒检测一次，主备之间必须一致</span><br><span class="line"></span><br><span class="line">authentication &#123; auth_type  PASS  auth_pass  123456 &#125;:心跳检测需要开放的账户密码</span><br><span class="line"></span><br><span class="line">virtual_ipaddress &#123;  172.18.0.201 &#125;:eth0定义的虚拟IP,可以设置多个虚拟IP地址，每行一个，只在docker内部能看得见</span><br></pre></td></tr></table></figure></p>
<p><font color="#660000">注意问题:</font><br><br>1、在执行apt-get update，发现docker 机无法解析dns，需要修改/etc/resolv.conf的nameserver 值为主机的值</p>
<p> <img src="images/docker13.jpg" alt=""></p>
<p> 主机DNS值<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli dev show | grep IP4.DNS</span><br></pre></td></tr></table></figure></p>
<p> 发现在ubuntu不能使用命令vi ，前提是要apt-get update，直接使用touch，echo</p>
<p> 备份<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv resolv.conf resolv.conf-bak</span><br></pre></td></tr></table></figure></p>
<p>  创建<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch resolv.conf</span><br></pre></td></tr></table></figure></p>
<p> 添加数据<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> nameserver 192.168.157.2 &gt; resolv.conf</span><br><span class="line"><span class="built_in">echo</span> options ndots:0 &gt;&gt;resolv.conf</span><br></pre></td></tr></table></figure></p>
<p> 2、apt-get镜像在国外，下载速度比较慢，添加阿里云镜像，修改vim /etc/apt/sources.list 文件，如果不能使用vim，可以先使用echo &gt;&gt; sources.list<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure></p>
<h4 id="宿主机安装Keepalived"><a href="#宿主机安装Keepalived" class="headerlink" title="宿主机安装Keepalived"></a>宿主机安装Keepalived</h4><p>安装Keepalived<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#宿主机执行安装Keepalived</span></span><br><span class="line">yum -y install keepalived</span><br><span class="line"><span class="comment">#修改Keepalived配置文件</span></span><br><span class="line">vi /etc/keepalived/keepalived.conf</span><br><span class="line"><span class="comment">#启动Keepalived</span></span><br><span class="line">service keepalived start</span><br></pre></td></tr></table></figure></p>
<p>Keepalived配置文件如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">       	192.168.157.135</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 192.168.157.135 8888 &#123;</span><br><span class="line">    delay_loop 3</span><br><span class="line">    lb_algo rr </span><br><span class="line">    lb_kind NAT</span><br><span class="line">    persistence_timeout 50</span><br><span class="line">    protocol TCP</span><br><span class="line"></span><br><span class="line">    real_server 172.18.0.201 8888 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 192.168.157.135 3306 &#123;</span><br><span class="line">    delay_loop 3</span><br><span class="line">    lb_algo rr </span><br><span class="line">    lb_kind NAT</span><br><span class="line">    persistence_timeout 50</span><br><span class="line">    protocol TCP</span><br><span class="line"></span><br><span class="line">    real_server 172.18.0.201 3306 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>配置文件解析<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">192.168.157.135：宿主机局域网的IP地址</span><br><span class="line"></span><br><span class="line">8888:对应容器Haproxy服务端口</span><br><span class="line"></span><br><span class="line">3306:对应容器Haproxy数据库端口</span><br><span class="line"></span><br><span class="line">172.18.0.201:keepalived争抢的IP地址</span><br></pre></td></tr></table></figure></p>
<h4 id="检测Keepalived高可用"><a href="#检测Keepalived高可用" class="headerlink" title="检测Keepalived高可用"></a>检测Keepalived高可用</h4><p>1、访问 Haproxy服务，ip地址是192.168.157.135，端口号上面设置8888<br> <img src="images/docker14.jpg" alt=""></p>
<p>2、使用navicat 登录 ，ip地址是192.168.157.135，端口号3306，账号密码自己设置的数据库账户密码<br> <img src="images/docker15.jpg" alt=""><br> <img src="images/docker16.jpg" alt=""></p>
<p>3、暂停其中的一个haproxy容器，查看是否还能使用</p>
<p>暂停容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pause h1</span><br></pre></td></tr></table></figure></p>
<p>运行暂停的容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker unpause h1</span><br></pre></td></tr></table></figure></p>
<p>可见集群还是能使用</p>
<h3 id="暂停-pxc集群方法"><a href="#暂停-pxc集群方法" class="headerlink" title="暂停 pxc集群方法"></a>暂停 pxc集群方法</h3><p>当要关闭Linux虚拟机，pxc如何关闭并如何保存，这些是有顺序的。最好是直接挂起虚拟机，而不是直接关闭虚拟机。挂起虚拟机，重新开启虚拟机，容器会直接恢复启动，但docker虚拟机得不到网络。从挂起状态恢复运行状态，为内部进程虚拟机分配网络，宿主机需要修改下面配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysctl.conf</span><br><span class="line"><span class="comment">#文件中添加 net.ipv4.ip_forward=1 这个配置</span></span><br><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure></p>
<h3 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h3><p>1、冷备份-暂停数据库运行<br> <img src="images/docker17.jpg" alt=""></p>
<p>2、热备份-数据库运行中<br><img src="images/docker18.jpg" alt=""></p>
<p>IVM :linux 自带的备份方式，分区里面的数据，可以备份多种数据库，备份要加锁，只读，不能写</p>
<p>XtraBackup :能读能写<br><img src="images/docker20.jpg" alt=""></p>
<p>热备份数据</p>
<p><img src="images/docker19.jpg" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#宿主机</span></span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it node1 bash</span><br><span class="line"><span class="comment">#更新软件包</span></span><br><span class="line">apt-get update</span><br><span class="line"><span class="comment">#安装热备工具</span></span><br><span class="line">apt-get install percona-xtrabackup-24</span><br><span class="line"><span class="comment">#全量热备到backup</span></span><br><span class="line">innobackupex --user=root --password=root /data/backup/full</span><br></pre></td></tr></table></figure></p>
<h3 id="数据库还原-只有冷还原"><a href="#数据库还原-只有冷还原" class="headerlink" title="数据库还原-只有冷还原"></a>数据库还原-只有冷还原</h3><p><img src="images/docker21.jpg" alt=""><br>冷还原数据 停止其余4个节点，并删除节点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker stop node2</span><br><span class="line">docker stop node3</span><br><span class="line">docker stop node4</span><br><span class="line">docker stop node5</span><br><span class="line">docker rm node2</span><br><span class="line">docker rm node3</span><br><span class="line">docker rm node4</span><br><span class="line">docker rm node5</span><br></pre></td></tr></table></figure>
<p>node1容器中删除MySQL的数据<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除数据</span></span><br><span class="line">rm -rf /var/lib/mysql/*</span><br><span class="line"><span class="comment">#清空事务</span></span><br><span class="line">innobackupex --user=root --password=abc123456 --apply-back /data/backup/full/2018-04-15_05-09-07/</span><br><span class="line"><span class="comment">#还原数据</span></span><br><span class="line">innobackupex --user=root --password=abc123456 --copy-back  /data/backup/full/2018-04-15_05-09-07/</span><br></pre></td></tr></table></figure></p>
<p>重新创建其余4个节点，组件PXC集群</p>
<h3 id="安装redis-集群"><a href="#安装redis-集群" class="headerlink" title="安装redis 集群"></a>安装redis 集群</h3><h4 id="高速缓存结束"><a href="#高速缓存结束" class="headerlink" title="高速缓存结束"></a>高速缓存结束</h4><p><img src="images/redis1.jpg" alt=""></p>
<h4 id="redis介绍"><a href="#redis介绍" class="headerlink" title="redis介绍"></a>redis介绍</h4><p><img src="images/redis2.jpg" alt=""></p>
<h4 id="redis集群介绍"><a href="#redis集群介绍" class="headerlink" title="redis集群介绍"></a>redis集群介绍</h4><p>主要使用RedisCluster方案<br><img src="images/redis3.jpg" alt=""></p>
<h4 id="RedisCluster方案介绍"><a href="#RedisCluster方案介绍" class="headerlink" title="RedisCluster方案介绍"></a>RedisCluster方案介绍</h4><p><img src="images/redis4.jpg" alt=""><br>主从同步</p>
<p><img src="images/redis5.jpg" alt=""></p>
<p>RedisCluster集群的高可用<br><img src="images/redis6.jpg" alt=""></p>
<h4 id="安装redis镜像，配置RedisCluster集群"><a href="#安装redis镜像，配置RedisCluster集群" class="headerlink" title="安装redis镜像，配置RedisCluster集群"></a>安装redis镜像，配置RedisCluster集群</h4><h5 id="安装Redis镜像"><a href="#安装Redis镜像" class="headerlink" title="安装Redis镜像"></a>安装Redis镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull yyyyttttwwww/redis</span><br></pre></td></tr></table></figure>
<h5 id="创建net2网段"><a href="#创建net2网段" class="headerlink" title="创建net2网段"></a>创建net2网段</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --subnet=172.19.0.0/16 net2</span><br></pre></td></tr></table></figure>
<h5 id="创建6节点Redis容器"><a href="#创建6节点Redis容器" class="headerlink" title="创建6节点Redis容器"></a>创建6节点Redis容器</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d --name r1 -p 5001:6379 --net=net2 --ip 172.19.0.2 redis bash</span><br><span class="line">docker run -it -d --name r2 -p 5002:6379 --net=net2 --ip 172.19.0.3 redis bash</span><br><span class="line">docker run -it -d --name r3 -p 5003:6379 --net=net2 --ip 172.19.0.4 redis bash</span><br><span class="line">docker run -it -d --name r4 -p 5004:6379 --net=net2 --ip 172.19.0.5 redis bash</span><br><span class="line">docker run -it -d --name r5 -p 5005:6379 --net=net2 --ip 172.19.0.6 redis bash</span><br><span class="line">docker run -it -d --name r6 -p 5006:6379 --net=net2 --ip 172.19.0.7 redis bash</span><br></pre></td></tr></table></figure>
<h5 id="启动6节点Redis服务器"><a href="#启动6节点Redis服务器" class="headerlink" title="启动6节点Redis服务器"></a>启动6节点Redis服务器</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入r1节点</span></span><br><span class="line">docker <span class="built_in">exec</span> -it r1 bash</span><br><span class="line">vi /usr/redis/redis.conf</span><br><span class="line"><span class="built_in">cd</span> /usr/redis/src</span><br><span class="line">./redis-server ../redis.conf</span><br><span class="line"><span class="comment">#进入r2节点</span></span><br><span class="line">docker <span class="built_in">exec</span> -it r2 bash</span><br><span class="line">vi /usr/redis/redis.conf</span><br><span class="line"><span class="built_in">cd</span> /usr/redis/src</span><br><span class="line">./redis-server ../redis.conf</span><br><span class="line"><span class="comment">#进入r3节点</span></span><br><span class="line">docker <span class="built_in">exec</span> -it r3 bash</span><br><span class="line">vi /usr/redis/redis.conf</span><br><span class="line"><span class="built_in">cd</span> /usr/redis/src</span><br><span class="line">./redis-server ../redis.conf</span><br><span class="line"><span class="comment">#进入r4节点</span></span><br><span class="line">docker <span class="built_in">exec</span> -it r4 bash</span><br><span class="line">vi /usr/redis/redis.conf</span><br><span class="line"><span class="built_in">cd</span> /usr/redis/src</span><br><span class="line">./redis-server ../redis.conf</span><br><span class="line"><span class="comment">#进入r5节点</span></span><br><span class="line">docker <span class="built_in">exec</span> -it r5 bash</span><br><span class="line">vi /usr/redis/redis.conf</span><br><span class="line"><span class="built_in">cd</span> /usr/redis/src</span><br><span class="line">./redis-server ../redis.conf</span><br><span class="line"><span class="comment">#进入r6节点</span></span><br><span class="line">docker <span class="built_in">exec</span> -it r6 bash</span><br><span class="line">vi /usr/redis/redis.conf</span><br><span class="line"><span class="built_in">cd</span> /usr/redis/src</span><br><span class="line">./redis-server ../redis.conf</span><br></pre></td></tr></table></figure>
<p>redis.conf配置文件修改的地方<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0  <span class="comment">#设置其他IP地址能访问，Cluster集群中的redis需要互相访问</span></span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure></p>
<p><img src="images/redis8.jpg" alt=""></p>
<h5 id="创建Cluster集群"><a href="#创建Cluster集群" class="headerlink" title="创建Cluster集群"></a>创建Cluster集群</h5><p>cluster是ruby写的，需要安装ruby环境，但上面方式安装的redis已经集成了，不再需要安装<br><img src="images/redis7.jpg" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在r1节点上执行下面的指令</span></span><br><span class="line"><span class="built_in">cd</span> /usr/redis/src</span><br><span class="line">mkdir -p ../cluster</span><br><span class="line">cp redis-trib.rb ../cluster/</span><br><span class="line"><span class="built_in">cd</span> ../cluster</span><br><span class="line"><span class="comment">#创建Cluster集群</span></span><br><span class="line">./redis-trib.rb create --replicas 1 172.19.0.2:6379 172.19.0.3:6379 172.19.0.4:6379 172.19.0.5:6379 172.19.0.6:6379 172.19.0.7:6379</span><br></pre></td></tr></table></figure></p>
<h5 id="重启redis"><a href="#重启redis" class="headerlink" title="重启redis"></a>重启redis</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep redis <span class="comment">#查看进程</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> -9 进程id  <span class="comment">#杀死进程</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/redis/src</span><br><span class="line"></span><br><span class="line">./redis-server ../redis.conf</span><br></pre></td></tr></table></figure>
<h3 id="部署后端的项目"><a href="#部署后端的项目" class="headerlink" title="部署后端的项目"></a>部署后端的项目</h3><h4 id="修改数据源配置"><a href="#修改数据源配置" class="headerlink" title="修改数据源配置"></a>修改数据源配置</h4><p>application_dev.yml</p>
<h4 id="修改redis配置"><a href="#修改redis配置" class="headerlink" title="修改redis配置"></a>修改redis配置</h4><p>application.yml<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#host: localhost</span></span><br><span class="line">  <span class="comment">#port: 6379</span></span><br><span class="line">  <span class="comment">#password:    # 密码（默认为空）</span></span><br><span class="line">  timeout: 6000ms  <span class="comment"># 连接超时时长（毫秒）</span></span><br><span class="line">  cluster:</span><br><span class="line">    nodes:</span><br><span class="line">    - 172.19.0.2:6379</span><br><span class="line">    - 172.19.0.3:6379</span><br><span class="line">    - 172.19.0.4:6379</span><br><span class="line">    - 172.19.0.5:6379</span><br><span class="line">    - 172.19.0.6:6379</span><br><span class="line">    - 172.19.0.7:6379</span><br><span class="line">  jedis:</span><br></pre></td></tr></table></figure></p>
<h4 id="进入人人开源后端项目，执行打包（修改配置文件，更改端口，打包三次生成三个JAR文件）"><a href="#进入人人开源后端项目，执行打包（修改配置文件，更改端口，打包三次生成三个JAR文件）" class="headerlink" title="进入人人开源后端项目，执行打包（修改配置文件，更改端口，打包三次生成三个JAR文件）"></a>进入人人开源后端项目，执行打包（修改配置文件，更改端口，打包三次生成三个JAR文件）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="安装Java镜像"><a href="#安装Java镜像" class="headerlink" title="安装Java镜像"></a>安装Java镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull java</span><br></pre></td></tr></table></figure>
<h4 id="创建3节点Java容器"><a href="#创建3节点Java容器" class="headerlink" title="创建3节点Java容器"></a>创建3节点Java容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建数据卷，上传JAR文件</span></span><br><span class="line">docker volume create j1</span><br><span class="line"><span class="comment">#启动容器</span></span><br><span class="line">docker run -it -d --name j1 -v j1:/home/soft --net=host java</span><br><span class="line"><span class="comment">#进入j1容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it j1 bash</span><br><span class="line"><span class="comment">#启动Java项目</span></span><br><span class="line">nohup java -jar /home/soft/renren-fast.jar</span><br><span class="line"><span class="comment">#查看日志</span></span><br><span class="line">tail -fn 50 nohup.out</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建数据卷，上传JAR文件</span></span><br><span class="line">docker volume create j2</span><br><span class="line"><span class="comment">#启动容器</span></span><br><span class="line">docker run -it -d --name j2 -v j2:/home/soft --net=host java</span><br><span class="line"><span class="comment">#进入j1容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it j2 bash</span><br><span class="line"><span class="comment">#启动Java项目</span></span><br><span class="line">nohup java -jar /home/soft/renren-fast.jar</span><br><span class="line"><span class="comment">#查看日志</span></span><br><span class="line">tail -fn 50 nohup.out</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建数据卷，上传JAR文件</span></span><br><span class="line">docker volume create j3</span><br><span class="line"><span class="comment">#启动容器</span></span><br><span class="line">docker run -it -d --name j3 -v j3:/home/soft --net=host java</span><br><span class="line"><span class="comment">#进入j1容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it j3 bash</span><br><span class="line"><span class="comment">#启动Java项目</span></span><br><span class="line">nohup java -jar /home/soft/renren-fast.jar</span><br><span class="line"><span class="comment">#查看日志</span></span><br><span class="line">tail -fn 50 nohup.out</span><br></pre></td></tr></table></figure>
<h4 id="访问网站"><a href="#访问网站" class="headerlink" title="访问网站"></a>访问网站</h4><p><a href="http://192.168.157.129:6001/renren-fast/swagger/index.html" target="_blank" rel="noopener">http://192.168.157.129:6001/renren-fast/swagger/index.html</a><br><img src="images/renren1.jpg" alt=""></p>
<h3 id="nginx-负载均衡"><a href="#nginx-负载均衡" class="headerlink" title="nginx 负载均衡"></a>nginx 负载均衡</h3><h4 id="安装Nginx镜像"><a href="#安装Nginx镜像" class="headerlink" title="安装Nginx镜像"></a>安装Nginx镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>
<h4 id="创建Nginx容器，配置负载均衡"><a href="#创建Nginx容器，配置负载均衡" class="headerlink" title="创建Nginx容器，配置负载均衡"></a>创建Nginx容器，配置负载均衡</h4><p><img src="images/renren3.jpg" alt=""></p>
<h5 id="宿主机上-home-n1-nginx-conf配置文件内容如下："><a href="#宿主机上-home-n1-nginx-conf配置文件内容如下：" class="headerlink" title="宿主机上/home/n1/nginx.conf配置文件内容如下："></a>宿主机上/home/n1/nginx.conf配置文件内容如下：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line">error_log  /var/<span class="built_in">log</span>/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                      <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                      <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br><span class="line"></span><br><span class="line">    access_log  /var/<span class="built_in">log</span>/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">	</span><br><span class="line">	proxy_redirect          off;</span><br><span class="line">	proxy_set_header        Host <span class="variable">$host</span>;</span><br><span class="line">	proxy_set_header        X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">	proxy_set_header        X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">	client_max_body_size    10m;</span><br><span class="line">	client_body_buffer_size   128k;</span><br><span class="line">	proxy_connect_timeout   5s;</span><br><span class="line">	proxy_send_timeout      5s;</span><br><span class="line">	proxy_read_timeout      5s;</span><br><span class="line">	proxy_buffer_size        4k;</span><br><span class="line">	proxy_buffers           4 32k;</span><br><span class="line">	proxy_busy_buffers_size  64k;</span><br><span class="line">	proxy_temp_file_write_size 64k;</span><br><span class="line">	</span><br><span class="line">	upstream tomcat &#123;</span><br><span class="line">		server 192.168.99.104:6001;</span><br><span class="line">		server 192.168.99.104:6002;</span><br><span class="line">		server 192.168.99.104:6003;</span><br><span class="line">	&#125;</span><br><span class="line">	server &#123;</span><br><span class="line">        listen       6101;</span><br><span class="line">        server_name  192.168.99.104; </span><br><span class="line">        location / &#123;  </span><br><span class="line">            proxy_pass   http://tomcat;</span><br><span class="line">            index  index.html index.htm;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="创建第1个Nginx节点"><a href="#创建第1个Nginx节点" class="headerlink" title="创建第1个Nginx节点"></a>创建第1个Nginx节点</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d --name n1 -v /home/n1/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx</span><br></pre></td></tr></table></figure>
<h5 id="宿主机上-home-n2-nginx-conf配置文件内容如下："><a href="#宿主机上-home-n2-nginx-conf配置文件内容如下：" class="headerlink" title="宿主机上/home/n2/nginx.conf配置文件内容如下："></a>宿主机上/home/n2/nginx.conf配置文件内容如下：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line">error_log  /var/<span class="built_in">log</span>/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                      <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                      <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br><span class="line"></span><br><span class="line">    access_log  /var/<span class="built_in">log</span>/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">	</span><br><span class="line">	proxy_redirect          off;</span><br><span class="line">	proxy_set_header        Host <span class="variable">$host</span>;</span><br><span class="line">	proxy_set_header        X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">	proxy_set_header        X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">	client_max_body_size    10m;</span><br><span class="line">	client_body_buffer_size   128k;</span><br><span class="line">	proxy_connect_timeout   5s;</span><br><span class="line">	proxy_send_timeout      5s;</span><br><span class="line">	proxy_read_timeout      5s;</span><br><span class="line">	proxy_buffer_size        4k;</span><br><span class="line">	proxy_buffers           4 32k;</span><br><span class="line">	proxy_busy_buffers_size  64k;</span><br><span class="line">	proxy_temp_file_write_size 64k;</span><br><span class="line">	</span><br><span class="line">	upstream tomcat &#123;</span><br><span class="line">		server 192.168.99.104:6001;</span><br><span class="line">		server 192.168.99.104:6002;</span><br><span class="line">		server 192.168.99.104:6003;</span><br><span class="line">	&#125;</span><br><span class="line">	server &#123;</span><br><span class="line">        listen       6102;</span><br><span class="line">        server_name  192.168.99.104; </span><br><span class="line">        location / &#123;  </span><br><span class="line">            proxy_pass   http://tomcat;</span><br><span class="line">            index  index.html index.htm;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="创建第2个Nginx节点"><a href="#创建第2个Nginx节点" class="headerlink" title="创建第2个Nginx节点"></a>创建第2个Nginx节点</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d --name n2 -v /home/n2/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx</span><br></pre></td></tr></table></figure>
<h3 id="后端项目双机热备负载均衡"><a href="#后端项目双机热备负载均衡" class="headerlink" title="后端项目双机热备负载均衡"></a>后端项目双机热备负载均衡</h3><p><img src="images/renren2.jpg" alt=""></p>
<h4 id="在Nginx容器安装Keepalived"><a href="#在Nginx容器安装Keepalived" class="headerlink" title="在Nginx容器安装Keepalived"></a>在Nginx容器安装Keepalived</h4><h5 id="n1节点keepalived"><a href="#n1节点keepalived" class="headerlink" title="n1节点keepalived"></a>n1节点keepalived</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入n1节点</span></span><br><span class="line">docker <span class="built_in">exec</span> -it n1 bash</span><br><span class="line"><span class="comment">#更新软件包</span></span><br><span class="line">apt-get update</span><br><span class="line"><span class="comment">#安装VIM</span></span><br><span class="line">apt-get install vim</span><br><span class="line"><span class="comment">#安装Keepalived</span></span><br><span class="line">apt-get install keepalived</span><br><span class="line"><span class="comment">#编辑Keepalived配置文件(如下)</span></span><br><span class="line">vim /etc/keepalived/keepalived.conf</span><br><span class="line"><span class="comment">#启动Keepalived</span></span><br><span class="line">service keepalived start</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 123456</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.99.151</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">virtual_server 192.168.99.151 6201 &#123;</span><br><span class="line">    delay_loop 3</span><br><span class="line">    lb_algo rr</span><br><span class="line">    lb_kind NAT</span><br><span class="line">    persistence_timeout 50</span><br><span class="line">    protocol TCP</span><br><span class="line">    real_server 192.168.99.104 6101 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="n2节点keepalived"><a href="#n2节点keepalived" class="headerlink" title="n2节点keepalived"></a>n2节点keepalived</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入n2节点</span></span><br><span class="line">docker <span class="built_in">exec</span> -it n2 bash</span><br><span class="line"><span class="comment">#更新软件包</span></span><br><span class="line">apt-get update</span><br><span class="line"><span class="comment">#安装VIM</span></span><br><span class="line">apt-get install vim</span><br><span class="line"><span class="comment">#安装Keepalived</span></span><br><span class="line">apt-get install keepalived</span><br><span class="line"><span class="comment">#编辑Keepalived配置文件(如下)</span></span><br><span class="line">vim /etc/keepalived/keepalived.conf</span><br><span class="line"><span class="comment">#启动Keepalived</span></span><br><span class="line">service keepalived start</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 123456</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.99.151</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">virtual_server 192.168.99.151 6201 &#123;</span><br><span class="line">    delay_loop 3</span><br><span class="line">    lb_algo rr</span><br><span class="line">    lb_kind NAT</span><br><span class="line">    persistence_timeout 50</span><br><span class="line">    protocol TCP</span><br><span class="line">    real_server 192.168.99.104 6102 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前端项目部署与负载均衡"><a href="#前端项目部署与负载均衡" class="headerlink" title="前端项目部署与负载均衡"></a>前端项目部署与负载均衡</h3><p><img src="images/docker22.jpg" alt=""></p>
<h4 id="设置前端连接后端的ip地址"><a href="#设置前端连接后端的ip地址" class="headerlink" title="设置前端连接后端的ip地址"></a>设置前端连接后端的ip地址</h4><p>比如<a href="http://192.168.157.129:6101/renren-fast" target="_blank" rel="noopener">http://192.168.157.129:6101/renren-fast</a><br><img src="images/renren4.jpg" alt=""></p>
<h4 id="打包部署前端项目"><a href="#打包部署前端项目" class="headerlink" title="打包部署前端项目"></a>打包部署前端项目</h4><h4 id="使用淘宝镜像-加速下载速度"><a href="#使用淘宝镜像-加速下载速度" class="headerlink" title="使用淘宝镜像,加速下载速度"></a>使用淘宝镜像,加速下载速度</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<h4 id="在前端项目路径下执行打包指令"><a href="#在前端项目路径下执行打包指令" class="headerlink" title="在前端项目路径下执行打包指令"></a>在前端项目路径下执行打包指令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br><span class="line"><span class="comment">#安装了淘宝镜像</span></span><br><span class="line">cnpm run build</span><br></pre></td></tr></table></figure>
<p>dish（build）目录的文件拷贝到宿主机的/home/fn1/renren-vue、/home/fn2/renren-vue、/home/fn3/renren-vue的目录下面</p>
<h4 id="创建3节点的Nginx，部署前端项目"><a href="#创建3节点的Nginx，部署前端项目" class="headerlink" title="创建3节点的Nginx，部署前端项目"></a>创建3节点的Nginx，部署前端项目</h4><h5 id="nginx-第一个节点"><a href="#nginx-第一个节点" class="headerlink" title="nginx 第一个节点"></a>nginx 第一个节点</h5><p>宿主机/home/fn1/nginx.conf的配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line">error_log  /var/<span class="built_in">log</span>/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                      <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                      <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br><span class="line"></span><br><span class="line">    access_log  /var/<span class="built_in">log</span>/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">	</span><br><span class="line">	proxy_redirect          off;</span><br><span class="line">	proxy_set_header        Host <span class="variable">$host</span>;</span><br><span class="line">	proxy_set_header        X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">	proxy_set_header        X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">	client_max_body_size    10m;</span><br><span class="line">	client_body_buffer_size   128k;</span><br><span class="line">	proxy_connect_timeout   5s;</span><br><span class="line">	proxy_send_timeout      5s;</span><br><span class="line">	proxy_read_timeout      5s;</span><br><span class="line">	proxy_buffer_size        4k;</span><br><span class="line">	proxy_buffers           4 32k;</span><br><span class="line">	proxy_busy_buffers_size  64k;</span><br><span class="line">	proxy_temp_file_write_size 64k;</span><br><span class="line">	</span><br><span class="line">	server &#123;</span><br><span class="line">		listen 6501;</span><br><span class="line">		server_name  192.168.99.104;</span><br><span class="line">		location  /  &#123;</span><br><span class="line">			root  /home/fn1/renren-vue;</span><br><span class="line">			index  index.html;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#启动第fn1节点</span></span><br><span class="line">docker run -it -d --name fn1 -v /home/fn1/nginx.conf:/etc/nginx/nginx.conf -v /home/fn1/renren-vue:/home/fn1/renren-vue --privileged --net=host nginx</span><br></pre></td></tr></table></figure></p>
<h5 id="nginx-第二个节点"><a href="#nginx-第二个节点" class="headerlink" title="nginx 第二个节点"></a>nginx 第二个节点</h5><p>宿主机/home/fn2/nginx.conf的配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line">error_log  /var/<span class="built_in">log</span>/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                      <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                      <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br><span class="line"></span><br><span class="line">    access_log  /var/<span class="built_in">log</span>/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">	</span><br><span class="line">	proxy_redirect          off;</span><br><span class="line">	proxy_set_header        Host <span class="variable">$host</span>;</span><br><span class="line">	proxy_set_header        X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">	proxy_set_header        X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">	client_max_body_size    10m;</span><br><span class="line">	client_body_buffer_size   128k;</span><br><span class="line">	proxy_connect_timeout   5s;</span><br><span class="line">	proxy_send_timeout      5s;</span><br><span class="line">	proxy_read_timeout      5s;</span><br><span class="line">	proxy_buffer_size        4k;</span><br><span class="line">	proxy_buffers           4 32k;</span><br><span class="line">	proxy_busy_buffers_size  64k;</span><br><span class="line">	proxy_temp_file_write_size 64k;</span><br><span class="line">	</span><br><span class="line">	server &#123;</span><br><span class="line">		listen 6502;</span><br><span class="line">		server_name  192.168.99.104;</span><br><span class="line">		location  /  &#123;</span><br><span class="line">			root  /home/fn2/renren-vue;</span><br><span class="line">			index  index.html;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#启动第fn2节点</span></span><br><span class="line">docker run -it -d --name fn2 -v /home/fn2/nginx.conf:/etc/nginx/nginx.conf -v /home/fn2/renren-vue:/home/fn2/renren-vue --privileged --net=host nginx</span><br></pre></td></tr></table></figure></p>
<h5 id="nginx-第三个节点"><a href="#nginx-第三个节点" class="headerlink" title="nginx 第三个节点"></a>nginx 第三个节点</h5><p>宿主机/home/fn3/nginx.conf的配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line">error_log  /var/<span class="built_in">log</span>/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                      <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                      <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br><span class="line"></span><br><span class="line">    access_log  /var/<span class="built_in">log</span>/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">	</span><br><span class="line">	proxy_redirect          off;</span><br><span class="line">	proxy_set_header        Host <span class="variable">$host</span>;</span><br><span class="line">	proxy_set_header        X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">	proxy_set_header        X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">	client_max_body_size    10m;</span><br><span class="line">	client_body_buffer_size   128k;</span><br><span class="line">	proxy_connect_timeout   5s;</span><br><span class="line">	proxy_send_timeout      5s;</span><br><span class="line">	proxy_read_timeout      5s;</span><br><span class="line">	proxy_buffer_size        4k;</span><br><span class="line">	proxy_buffers           4 32k;</span><br><span class="line">	proxy_busy_buffers_size  64k;</span><br><span class="line">	proxy_temp_file_write_size 64k;</span><br><span class="line">	</span><br><span class="line">	server &#123;</span><br><span class="line">		listen 6503;</span><br><span class="line">		server_name  192.168.99.104;</span><br><span class="line">		location  /  &#123;</span><br><span class="line">			root  /home/fn3/renren-vue;</span><br><span class="line">			index  index.html;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">启动fn3节点</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动第fn3节点</span></span><br><span class="line">docker run -it -d --name fn3 -v /home/fn3/nginx.conf:/etc/nginx/nginx.conf -v /home/fn3/renren-vue:/home/fn3/renren-vue --privileged --net=host nginx</span><br></pre></td></tr></table></figure></p>
<h5 id="利用keepalived配置负载均衡"><a href="#利用keepalived配置负载均衡" class="headerlink" title="利用keepalived配置负载均衡"></a>利用keepalived配置负载均衡</h5><h6 id="ff1-keepalived-nginx节点"><a href="#ff1-keepalived-nginx节点" class="headerlink" title="ff1  keepalived-nginx节点"></a>ff1  keepalived-nginx节点</h6><p>宿主机/home/ff1/nginx.conf配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line">error_log  /var/<span class="built_in">log</span>/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                      <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                      <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br><span class="line"></span><br><span class="line">    access_log  /var/<span class="built_in">log</span>/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">	</span><br><span class="line">	proxy_redirect          off;</span><br><span class="line">	proxy_set_header        Host <span class="variable">$host</span>;</span><br><span class="line">	proxy_set_header        X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">	proxy_set_header        X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">	client_max_body_size    10m;</span><br><span class="line">	client_body_buffer_size   128k;</span><br><span class="line">	proxy_connect_timeout   5s;</span><br><span class="line">	proxy_send_timeout      5s;</span><br><span class="line">	proxy_read_timeout      5s;</span><br><span class="line">	proxy_buffer_size        4k;</span><br><span class="line">	proxy_buffers           4 32k;</span><br><span class="line">	proxy_busy_buffers_size  64k;</span><br><span class="line">	proxy_temp_file_write_size 64k;</span><br><span class="line">	</span><br><span class="line">	upstream fn &#123;</span><br><span class="line">		server 192.168.99.104:6501;</span><br><span class="line">		server 192.168.99.104:6502;</span><br><span class="line">		server 192.168.99.104:6503;</span><br><span class="line">	&#125;</span><br><span class="line">	server &#123;</span><br><span class="line">        listen       6601;</span><br><span class="line">        server_name  192.168.99.104; </span><br><span class="line">        location / &#123;  </span><br><span class="line">            proxy_pass   http://fn;</span><br><span class="line">            index  index.html index.htm;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#启动ff1节点</span></span><br><span class="line">docker run -it -d --name ff1 -v /home/ff1/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx</span><br></pre></td></tr></table></figure></p>
<h6 id="ff2-keepalived-nginx节点"><a href="#ff2-keepalived-nginx节点" class="headerlink" title="ff2  keepalived-nginx节点"></a>ff2  keepalived-nginx节点</h6><p>宿主机/home/ff2/nginx.conf配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line">error_log  /var/<span class="built_in">log</span>/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                      <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                      <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br><span class="line"></span><br><span class="line">    access_log  /var/<span class="built_in">log</span>/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">	</span><br><span class="line">	proxy_redirect          off;</span><br><span class="line">	proxy_set_header        Host <span class="variable">$host</span>;</span><br><span class="line">	proxy_set_header        X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">	proxy_set_header        X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">	client_max_body_size    10m;</span><br><span class="line">	client_body_buffer_size   128k;</span><br><span class="line">	proxy_connect_timeout   5s;</span><br><span class="line">	proxy_send_timeout      5s;</span><br><span class="line">	proxy_read_timeout      5s;</span><br><span class="line">	proxy_buffer_size        4k;</span><br><span class="line">	proxy_buffers           4 32k;</span><br><span class="line">	proxy_busy_buffers_size  64k;</span><br><span class="line">	proxy_temp_file_write_size 64k;</span><br><span class="line">	</span><br><span class="line">	upstream fn &#123;</span><br><span class="line">		server 192.168.99.104:6501;</span><br><span class="line">		server 192.168.99.104:6502;</span><br><span class="line">		server 192.168.99.104:6503;</span><br><span class="line">	&#125;</span><br><span class="line">	server &#123;</span><br><span class="line">        listen       6602;</span><br><span class="line">        server_name  192.168.99.104; </span><br><span class="line">        location / &#123;  </span><br><span class="line">            proxy_pass   http://fn;</span><br><span class="line">            index  index.html index.htm;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#启动ff2节点</span></span><br><span class="line">docker run -it -d --name ff2 -v /home/ff2/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx</span><br></pre></td></tr></table></figure></p>
<h5 id="配置双机热备"><a href="#配置双机热备" class="headerlink" title="配置双机热备"></a>配置双机热备</h5><h6 id="ff1节点安装keepalived"><a href="#ff1节点安装keepalived" class="headerlink" title="ff1节点安装keepalived"></a>ff1节点安装keepalived</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入ff1节点</span></span><br><span class="line">docker <span class="built_in">exec</span> -it ff1 bash</span><br><span class="line"><span class="comment">#更新软件包</span></span><br><span class="line">apt-get update</span><br><span class="line"><span class="comment">#安装VIM</span></span><br><span class="line">apt-get install vim</span><br><span class="line"><span class="comment">#安装Keepalived</span></span><br><span class="line">apt-get install keepalived</span><br><span class="line"><span class="comment">#编辑Keepalived配置文件(如下)</span></span><br><span class="line">vim /etc/keepalived/keepalived.conf</span><br><span class="line"><span class="comment">#启动Keepalived</span></span><br><span class="line">service keepalived start</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 52</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 123456</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.99.152</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">virtual_server 192.168.99.151 6701 &#123;</span><br><span class="line">    delay_loop 3</span><br><span class="line">    lb_algo rr</span><br><span class="line">    lb_kind NAT</span><br><span class="line">    persistence_timeout 50</span><br><span class="line">    protocol TCP</span><br><span class="line">    real_server 192.168.99.104 6601 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="ff2节点安装keepalived"><a href="#ff2节点安装keepalived" class="headerlink" title="ff2节点安装keepalived"></a>ff2节点安装keepalived</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入ff2节点</span></span><br><span class="line">docker <span class="built_in">exec</span> -it ff2 bash</span><br><span class="line"><span class="comment">#更新软件包</span></span><br><span class="line">apt-get update</span><br><span class="line"><span class="comment">#安装VIM</span></span><br><span class="line">apt-get install vim</span><br><span class="line"><span class="comment">#安装Keepalived</span></span><br><span class="line">apt-get install keepalived</span><br><span class="line"><span class="comment">#编辑Keepalived配置文件(如下)</span></span><br><span class="line">vim /etc/keepalived/keepalived.conf</span><br><span class="line"><span class="comment">#启动Keepalived</span></span><br><span class="line">service keepalived start</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 52</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 123456</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.99.152</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">virtual_server 192.168.99.151 6701 &#123;</span><br><span class="line">    delay_loop 3</span><br><span class="line">    lb_algo rr</span><br><span class="line">    lb_kind NAT</span><br><span class="line">    persistence_timeout 50</span><br><span class="line">    protocol TCP</span><br><span class="line">    real_server 192.168.99.104 6602 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="index-post card" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/26/concurrencyPlan/concurrency_plan/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="龙门小左">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="程序猿的日常">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2018/06/26/concurrencyPlan/concurrency_plan/" itemprop="url">JAVA并发编程与高并发解决方案 - 高并发解决方案</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2018-06-26T10:00:00+08:00">2018-06-26 10:00:00</time></span>
        </span>
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="JAVA并发编程与高并发解决方案-高并发解决方案"><a href="#JAVA并发编程与高并发解决方案-高并发解决方案" class="headerlink" title="JAVA并发编程与高并发解决方案 - 高并发解决方案"></a>JAVA并发编程与高并发解决方案 - 高并发解决方案</h1><table>
<thead>
<tr>
<th style="text-align:center">版本</th>
<th style="text-align:center">作者</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2018.06.26</td>
<td style="text-align:center">huangzuo</td>
<td style="text-align:center">首次发布</td>
</tr>
</tbody>
</table>
<h2 id="学习内容简介"><a href="#学习内容简介" class="headerlink" title="学习内容简介"></a>学习内容简介</h2><pre><code>本章节主要大概介绍了高并发环境下主要处理思路和手段，能够应对何种高并发环境使用什么样的思路和手段方法。主要思路和手段方法有下面几种:
1.扩容、
2.缓存、
3.队列、
4.拆分、
5.服务降级与熔断、
6.数据库切库、
7.分库分表 etc.
</code></pre><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>  垂直扩容(纵向扩展):提高系统部件能力。对单个服务器，提高cpu速度或者增加内存、存储空间等。但单个服务器扩容能力是有限</p>
<p>  水平扩容(横向扩容)：增加服务器</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>服务器和数据库的资源是有限的，如何使用有限的资源支持更多的吞吐量，一个有效的方法是使用缓存，下面四个环节都可以使用缓存中的数据，从而减少对服务器的访问和计算量，提高并发量</p>
<p>用户通过浏览器访问网站，主要路径有:下面图四个节点，每个节点都有缓存，这里只是描述服务端和数据库的缓存<br><img src="images/19.jpg" alt=""></p>
<h4 id="缓存特征"><a href="#缓存特征" class="headerlink" title="缓存特征"></a>缓存特征</h4><p>缓存数据是从数据库中取的部分数据，缓存中的数据是有限，并有时间等限制，还要保持缓存中的数据和数据库中数据的一致性，所以不得不关注缓存中的一些特征</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h3 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h3><h3 id="服务降级与熔断"><a href="#服务降级与熔断" class="headerlink" title="服务降级与熔断"></a>服务降级与熔断</h3><h3 id="数据库切库"><a href="#数据库切库" class="headerlink" title="数据库切库"></a>数据库切库</h3><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3>
      
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="index-post card" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/21/concurrency/concurrency-2/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="龙门小左">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="程序猿的日常">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2018/06/21/concurrency/concurrency-2/" itemprop="url">JAVA并发编程与高并发解决方案 - 并发编程 二</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2018-06-21T10:00:00+08:00">2018-06-21 10:00:00</time></span>
        </span>
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="JAVA并发编程与高并发解决方案-并发编程-二"><a href="#JAVA并发编程与高并发解决方案-并发编程-二" class="headerlink" title="JAVA并发编程与高并发解决方案 - 并发编程 二"></a>JAVA并发编程与高并发解决方案 - 并发编程 二</h1><table>
<thead>
<tr>
<th style="text-align:center">版本</th>
<th style="text-align:center">作者</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2018.4.8</td>
<td style="text-align:center">chuIllusions</td>
<td style="text-align:center">线程安全性、安全发布对象</td>
</tr>
</tbody>
</table>
<h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p>​    当多个线程访问某个类时，不管运行时环境采用<strong>何种调度方式</strong>或者这些进程将如何交替执行，并且在主调代码中<strong>不需要任何额外的同步或协调</strong>，这个类都能表现出<strong>正确的行为</strong>，那么就称这个类是线程安全的。</p>
<p>线程安全性主要体现：</p>
<ol>
<li>原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作</li>
<li>可见性：一个线程对主内存的修改可以及时的被其他线程观察到</li>
<li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般是杂乱无序</li>
</ol>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><h5 id="Atomic包"><a href="#Atomic包" class="headerlink" title="Atomic包"></a>Atomic包</h5><p>位于java.util.concurrent.atomic</p>
<p>AtomicXXX : CAS、Unsafe.compareAndSwapXXX</p>
<p>​    CAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术。简单来说，比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。</p>
<h6 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line">	<span class="comment">//从int类型换成了AtomicInteger</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用了AtomicInteger方法</span></span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">        <span class="comment">// count.getAndIncrement();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程安全？源码分析</p>
<p><code>AtomicInteger.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe(); <span class="comment">//通过反射获得</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       valueOffset = unsafe.objectFieldOffset</span><br><span class="line">       (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//this 代表当前AtomicInteger对象</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Unsafe.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本地方法，java底层方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> var1 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> var2 偏移量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> var3 期望值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> var5 修改值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> var1 当前对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> var2 当前值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> var3 增量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5; <span class="comment">//底层值</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    	<span class="comment">// CAS核心</span></span><br><span class="line">		<span class="comment">//当前值与底层值相同，则更新成var5 + var4</span></span><br><span class="line">    	<span class="comment">//不一样则不停的循环，直到值相同</span></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="AtomicInLong-与-LongAdder"><a href="#AtomicInLong-与-LongAdder" class="headerlink" title="AtomicInLong 与 LongAdder"></a>AtomicInLong 与 LongAdder</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicLong count = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">        <span class="comment">// count.getAndIncrement();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LongAdder count = <span class="keyword">new</span> LongAdder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count.increment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AtomicInLong 与 LongAdder 比较</p>
<p>​    就像我们所知道的那样,AtomicLong的原理是依靠底层的cas来保障原子性的更新数据，在要添加或者减少的时候，会使用死循环不断地cas到特定的值，从而达到更新数据的目的。如果竞争不激烈，修改成功几率很高，否则失败概率很高，在失败几率很高的情况下，这些原子操作就会进行多次的循环操作尝试，因此性能会受到影响。</p>
<p>​    对于普通类型的Long和Doubble变量，JVM允许将64位的读操作或写操作拆成两个三十二位的操作。</p>
<p>​    LongAdder的核心是将热点数据分离，比如说它可以将AtomicLong内部核心数据value分离成一个数组，每个线程访问时，通过hash等算法，映射到其中一个数字进行计数，最终的计数结果则会这个数据的求和累加，其中热点数据value会被分离成多个cell，每个cell独自维护内部的值，当前对象实际值为所有cell累计合成，这样的话，热点就进行了有效的分离，并提高了并行度。</p>
<p>​    LongAdder在AtomicLong的基础上将单点的更新压力分散到各个节点，在低并发的时候通过对base的直接更新可以很好的保障和AtomicLong的性能基本保持一致，而在高并发的时候通过分散提高了性能。 </p>
<p>​    缺点是LongAdder在统计的时候如果有并发更新，可能导致统计的数据有误差。</p>
<p>​    实际使用中，在处理高并发时，可以优先使用LongAdder，而不是继续使用AtomicLong，当然，在线程竞争很低的情况下，使用AtomicLong更简单更实际一些，并且效率会高些。其他情况下，比如序列号生成，这种情况下需要准确的数值，全局唯一的AtomicLong才是正确的选择，而不是LongAdder</p>
<pre><code>&gt; 参考文章 [AtomicLong和LongAdder的区别](https://blog.csdn.net/yao123long/article/details/63683991)
</code></pre><h6 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h6><blockquote>
<p>The <code>AtomicReference</code> class provides reference objects that may be read and written atomically, so when multiple threads try to reach them at the same time, only one will be able to do so</p>
</blockquote>
<p>原子性引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;Integer&gt; count = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        count.compareAndSet(<span class="number">0</span>, <span class="number">2</span>); <span class="comment">// 2</span></span><br><span class="line">        count.compareAndSet(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// no</span></span><br><span class="line">        count.compareAndSet(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// no</span></span><br><span class="line">        count.compareAndSet(<span class="number">2</span>, <span class="number">4</span>); <span class="comment">// 4</span></span><br><span class="line">        count.compareAndSet(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">// no</span></span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实例比较简单，我有个疑问？假如我们引用的是一个自定义的对象，并且对象里面有属性值，然后，修改对象中的属性值也是原子性的吗？还是只是对对象的引用是原子性操作。</p>
<p><strong>带着上面的疑问，进行源码分析</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReference</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1848883965231344442L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicReference.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicReference with the given initial value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicReference</span><span class="params">(V initialValue)</span> </span>&#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicReference with null initial value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不需要安全防护</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设值值不需要进行对象安全防护</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 很明显调用的是csa操作</span></span><br><span class="line"><span class="comment">     * 比较对象是否相同，进行设值</span></span><br><span class="line"><span class="comment">     * 设值成功返回true，否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置新的值并且返回旧的值</span></span><br><span class="line"><span class="comment">     * 原子操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndSet</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (V)unsafe.getAndSetObject(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过源码分析，可以得出</p>
<ul>
<li>AtomicReference 所提供的某些方法可以进行原子性操作，如compareAndSet、getAndSet，这仅仅是对引用进行原子性操作</li>
<li>AtomicReference  不能保证对象中若存在属性值修改是线程安全的，如假设引用对象是person，修改person中name和age，多个线程同时从引用中获得对象，并进行修改，会出现线程不安全情况。下面我们通过代码来验证一下这条结论。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Person person = <span class="keyword">new</span> Person(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicReference&lt;Person&gt; personAtomicReference = <span class="keyword">new</span> AtomicReference(person);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> result = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    modify(result);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"name:&#123;&#125;,age:&#123;&#125;"</span>,personAtomicReference.get().getName(), personAtomicReference.get().getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果线程安全的话，age的值和name的值是一致的</span></span><br><span class="line">    <span class="comment">//如果线程不安全的话，age的值和name是不一样的。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        personAtomicReference.get().setAge(personAtomicReference.get().getAge() + i);</span><br><span class="line">        personAtomicReference.get().setName(personAtomicReference.get().getName() + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在低并发的情况下，输出的结果是正确的，但是在高并发的情况下结果差距就很大了</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18:09:52.473 [main] INFO com.mmall.concurrency.example.atomic.AtomicReferenceTest - name:496592,age:496922</span><br></pre></td></tr></table></figure>
<h6 id="AtomicReferenceFieldUpdater"><a href="#AtomicReferenceFieldUpdater" class="headerlink" title="AtomicReferenceFieldUpdater"></a>AtomicReferenceFieldUpdater</h6><p>​    atomic包中提供AtomicReferenceFieldUpdater、AtomicIntegerFieldUpdater、AtomicLongFieldUpdater，原子性的更新某一个类实例的指定的某一个字段</p>
<ul>
<li>AtomicIntegerFieldUpdater</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicExample5</span> </span>&#123;</span><br><span class="line">	<span class="comment">//AtomicIntegerFieldUpdater 原子性的更新某一个类的实例的指定的某一个字段</span></span><br><span class="line">    <span class="comment">//并且该字段由volatile进行修饰同时不能被static修饰</span></span><br><span class="line">    <span class="comment">//有些网上说而且不能被private修饰？下文将进行验证</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;AtomicExample5&gt; updater =</span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(AtomicExample5.class, <span class="string">"count"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AtomicExample5 example5 = <span class="keyword">new</span> AtomicExample5();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (updater.compareAndSet(example5, <span class="number">100</span>, <span class="number">120</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">"update success 1, &#123;&#125;"</span>, example5.getCount());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (updater.compareAndSet(example5, <span class="number">100</span>, <span class="number">120</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">"update success 2, &#123;&#125;"</span>, example5.getCount());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"update failed, &#123;&#125;"</span>, example5.getCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果输出</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">18:48:27.815 [main] INFO com.mmall.concurrency.example.atomic.AtomicExample5 - update success 1, 120</span><br><span class="line">18:48:27.825 [main] INFO com.mmall.concurrency.example.atomic.AtomicExample5 - update failed, 120</span><br></pre></td></tr></table></figure>
<p><strong>源码分析</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdater</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tclass 持有某字段的类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fieldName 字段名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">AtomicIntegerFieldUpdater&lt;U&gt; <span class="title">newUpdater</span><span class="params">(Class&lt;U&gt; tclass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                              String fieldName)</span>     </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AtomicIntegerFieldUpdaterImpl&lt;U&gt;</span><br><span class="line">            (tclass, fieldName, Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原子性设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(T obj, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = get(obj);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(obj, prev, newValue));</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterImpl</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">            <span class="keyword">extends</span> <span class="title">AtomicIntegerFieldUpdater</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> offset;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; tclass;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; cclass;</span><br><span class="line"></span><br><span class="line">        AtomicIntegerFieldUpdaterImpl(<span class="keyword">final</span> Class&lt;T&gt; tclass,</span><br><span class="line">                                      <span class="keyword">final</span> String fieldName,</span><br><span class="line">                                      <span class="keyword">final</span> Class&lt;?&gt; caller) &#123;</span><br><span class="line">            <span class="keyword">final</span> Field field;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> modifiers;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                field = AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> PrivilegedExceptionAction&lt;Field&gt;() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Field <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">                            <span class="comment">//字段不存在会抛异常</span></span><br><span class="line">                            <span class="keyword">return</span> tclass.getDeclaredField(fieldName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                 <span class="comment">//检查访问级别</span></span><br><span class="line">                modifiers = field.getModifiers();</span><br><span class="line">                sun.reflect.misc.ReflectUtil.ensureMemberAccess(</span><br><span class="line">                    caller, tclass, <span class="keyword">null</span>, modifiers);</span><br><span class="line">                ClassLoader cl = tclass.getClassLoader();</span><br><span class="line">                ClassLoader ccl = caller.getClassLoader();</span><br><span class="line">                <span class="keyword">if</span> ((ccl != <span class="keyword">null</span>) &amp;&amp; (ccl != cl) &amp;&amp;</span><br><span class="line">                    ((cl == <span class="keyword">null</span>) || !isAncestor(cl, ccl))) &#123;</span><br><span class="line">                  sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(pae.getException());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; fieldt = field.getType();</span><br><span class="line">			<span class="comment">//必须是int</span></span><br><span class="line">            <span class="keyword">if</span> (fieldt != <span class="keyword">int</span>.class)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Must be integer type"</span>);</span><br><span class="line">			<span class="comment">//必须用volatile修饰</span></span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isVolatile(modifiers))</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Must be volatile type"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.cclass = (Modifier.isProtected(modifiers) &amp;&amp;</span><br><span class="line">                           caller != tclass) ? caller : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.tclass = tclass;</span><br><span class="line">			<span class="comment">//用Unsafe里的那一坨方法去原子更新</span></span><br><span class="line">            offset = unsafe.objectFieldOffset(field);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    从源码分析中，可以看出没有要求不能被private修饰</p>
<h6 id="AtomicStampReference"><a href="#AtomicStampReference" class="headerlink" title="AtomicStampReference"></a>AtomicStampReference</h6><p>​    此类是要核心解决CAS的ABA问题</p>
<p>​    ABA问题：指CAS操作的时候，线程将某个变量值由A修改为B，但是又改回了A，其他线程发现A并未改变，于是CAS将进行值交换操作，实际上该值已经被改变过，这与CAS的核心思想是不符合的</p>
<p>​    解决思路：每次变量更新的时候，把变量的版本号进行更新，如果某变量被某个线程修改过，那么版本号一定会递增更新，从而解决ABA问题</p>
<p>​    J.U.C 提供了两个类解决ABA问题，一个是<code>AtomicStampReference</code> ，另一个是 <code>AtomicMarkableReference</code></p>
<h6 id="AtomicLongArray"><a href="#AtomicLongArray" class="headerlink" title="AtomicLongArray"></a>AtomicLongArray</h6><p>​    AtomicLong是作用是对长整形进行原子操作。而AtomicLongArray的作用则是对”长整形数组”进行原子操作,根据索引，对数据中的指定位置的数据进行院子性的更新</p>
<h6 id="AtomicBoolean"><a href="#AtomicBoolean" class="headerlink" title="AtomicBoolean"></a>AtomicBoolean</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicExample6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicBoolean isHappened = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    test();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"isHappened:&#123;&#125;"</span>, isHappened.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 演示如何让一段代码中的某个逻辑在高并发场景下只执行一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//原子性操作，保证从false 到 true 只会执行一次</span></span><br><span class="line">        <span class="keyword">if</span> (isHappened.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">"execute"</span>); <span class="comment">//只会执行一次</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h5><p>​    JAVA中能保证同一时刻，只有一个线程来进行对其进行操作的，除了atomic包中所提供的类之外，还有jdk提供的锁，JAVA主要提供以下锁：</p>
<ol>
<li>synchronized : 关键字，并且依赖与JVM，<strong>作用对象的作用范围内</strong>都是同一时刻只能有一个线程对其操作的</li>
<li>Lock : 接口类，依赖特殊的CPU指定，使用代码实现，常用子类ReentrantLock</li>
</ol>
<h6 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h6><ul>
<li>修饰代码块：大括号括起来的代码，也称同步代码块，作用与<strong>调用的对象</strong></li>
<li>修饰方法：整个方法，也称同步方法，作用与<strong>调用的对象</strong></li>
<li>修饰静态方法：整个静态方法，作用于<strong>类的所有对象</strong></li>
<li>修饰类：括号括起来的部分，作用与<strong>类的所有对象</strong></li>
</ul>
<p><strong>同步代码块与同步方法演示与解析</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰一个代码块</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//同步代码块 作用于调用的对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                log.info(<span class="string">"test1 &#123;&#125; - &#123;&#125;"</span>, j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰一个方法 同步方法 作用于调用的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            log.info(<span class="string">"test2 &#123;&#125; - &#123;&#125;"</span>, j, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedExample1 example1 = <span class="keyword">new</span> SynchronizedExample1();</span><br><span class="line">        SynchronizedExample1 example2 = <span class="keyword">new</span> SynchronizedExample1();</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example1.test2(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//example1.test2(1)</span></span><br><span class="line">            example2.test2(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若线程池中开启两个线程：</p>
<p>​    使用同步方法进行验证：</p>
<p>​    若两个线程中都使用同一个对象进行操作，那么他们是同步的,输出的结果都是先执行test2-1 0-9的输出后执行test2-2 0-9的输出或先执行test2-2 0-9的输出后执行test2-1 0-9的输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">    example1.test2(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">    example1.test2(<span class="number">2</span>)</span><br><span class="line">    <span class="comment">//example2.test2(2);</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>​    若两个线程中不使用同一个对象进行操作，那么他们输出即为交叉执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">    example1.test2(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//example1.test2(2)</span></span><br><span class="line">    example2.test2(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>​    注意：如果某个类为父类，并且存在同步方法，子类在继承这个类后，如果子类调用该父类的同步方法后，该方法是没有synchronized关键字的，原因是synchronized不属于方法声明的一部分</p>
<p><strong>修饰静态方法与修饰类演示与解析</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="comment">//作用于类的所有对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰一个类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedExample2.class) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                log.info(<span class="string">"test1 &#123;&#125; - &#123;&#125;"</span>, j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰一个静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            log.info(<span class="string">"test2 &#123;&#125; - &#123;&#125;"</span>, j, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedExample2 example1 = <span class="keyword">new</span> SynchronizedExample2();</span><br><span class="line">        SynchronizedExample2 example2 = <span class="keyword">new</span> SynchronizedExample2();</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example1.test1(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//example1.test2(1);</span></span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example2.test1(<span class="number">2</span>);</span><br><span class="line">            <span class="comment">//example2.test2(2);</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面类的执行结果，同一个类的不同对象执行同步修饰的方法，执行的顺序是同步的</p>
<h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><ol>
<li>synchronized ：不可中断锁，适合竞争不激烈，可读性较好</li>
<li>Lock：可中断锁，多样化同步，竞争激烈时能维持常态</li>
<li>Atomic：竞争激烈时能维持常态，比Lock性能好；只能同步一个值</li>
</ol>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>​    一个线程对主内存的修改可以及时的被其他线程观察到。</p>
<p>​    导致共享变量在线程间不可见的原因：</p>
<ol>
<li>线程交叉执行</li>
<li>重排序结合线程交叉执行</li>
<li>共享变量更新后的值没有在工作内存与主存间及时更新</li>
</ol>
<p>对于可见性，JVM提供了 <code>synchronized</code> 和 <code>volatile</code></p>
<h5 id="synchronized-1"><a href="#synchronized-1" class="headerlink" title="synchronized"></a>synchronized</h5><p>​    JMM关于synchronized的两条规定：</p>
<ul>
<li>线程解锁前，必须把共享变量的最新值刷新到主内存</li>
<li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（注意：加锁与解锁是同一把锁）</li>
</ul>
<h5 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h5><h6 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h6><p>​    通过加入<strong>内存屏障</strong>和<strong>禁止重排序</strong>优化来实现</p>
<ul>
<li><p>对volatile变量<strong>写操作</strong>时，会在写操作<strong>后</strong>加入一条<strong>store屏障</strong>指令，将本地内存中的共享变量值刷新到主内存中<img src="images/volatile-1.png" alt=""></p>
</li>
<li><p>对volatile变量<strong>读操作</strong>是，会在读操作<strong>前</strong>加入一条<strong>load屏障</strong>指令，从主内存中读取共享变量<img src="images/volatile-2.png" alt=""></p>
<p>​</p>
<p>通过上面两点，任何时候，不同的线程总能看到该变量的最新值。所有的指令操作都是CPU级别的</p>
</li>
</ul>
<h6 id="Verification"><a href="#Verification" class="headerlink" title="Verification"></a>Verification</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出结果是线程不安全的。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过例子可以得知，即使通过volatile修饰变量，但依然无法保证线程安全</p>
<p>原因分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count++; <span class="comment">//分3步</span></span><br><span class="line">    <span class="comment">//1.取出当前count值</span></span><br><span class="line">    <span class="comment">//2.count + 1</span></span><br><span class="line">    <span class="comment">//3.count 重新写回主存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设同时有两个线程进行操作，两个线程同时执行到第一步（从内存中读取最新值）得到一样的最新的结果，然后进入第二步（+1操作）并进行第三步（从新写回主存）。尽管第一步获取的值是一样的，但是同时将+1后的操作写回主存，这样就会丢掉某个+1的操作，这样就会出现线程不安全问题</p>
<p>结论：</p>
<ul>
<li>volatile进行加操作线程不安全的，不适合计数场景</li>
<li>volatile关键字不具有原子性</li>
</ul>
<h6 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h6><p>​    使用volatile必须具备两个条件</p>
<ul>
<li>对变量的写操作，不依赖于当前值</li>
<li>该变量没有包含在具有其他变量的不变式子中</li>
</ul>
<p>因此volatile适合作为状态的标记量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> inited = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line">context = loadContext();</span><br><span class="line">inited = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="keyword">while</span>(!inited)&#123;</span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br><span class="line">doSomethingWithConfig(context);</span><br></pre></td></tr></table></figure>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>​    JAVA内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性</p>
<p>​    volatile、synchronized、Lock：通过volatile、synchronized、Lock保证一定的有序性。显然，synchronized、Lock保证每一个时刻只有一个线程可以执行被同步的代码，相当于让线程顺序执行同步代码，从而保证有序性。另外，JMM具备一些先天的有序性，即不需要额外的手段，就能保证有序性，即Happens-before原则，<strong>如果两个操作的执行次序，没有办法通过Happens-before原则推到出来，虚拟机进行随意的重排序，那么就不能保证有序行</strong>。</p>
<h6 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h6><ul>
<li><strong>程序次序规则</strong>：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>
</ul>
<p>(个人理解：一段程序代码的执行，在单个线程中看起来是有序的，程序看起来的执行是按照代码的顺序执行的，因为虚拟机可能会对指令进行重排序，虽然进行了重排序，但是最终结果是与程序顺序执行的结果是一致的，只会对不存在数据依赖的指令进行重排序，因此在单个线程中是有序执行的。这条规则是保证程序在单线程中执行结果的正确性，但无法保证多线程执行结果的正确性)</p>
<ul>
<li><strong>锁定规则</strong>：一个unLock操作先行发生于后面对同一个锁额lock操作；</li>
<li><strong>volatile变量规则</strong>：对一个变量的写操作先行发生于后面对这个变量的读操作；</li>
<li><strong>传递规则</strong>：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</li>
<li><strong>线程启动规则</strong>：Thread对象的start()方法先行发生于此线程的每个一个动作；</li>
<li><strong>线程中断规则</strong>：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li>
<li><strong>线程终结规则</strong>：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li>
<li><strong>对象终结规则</strong>：一个对象的初始化完成先行发生于他的finalize()方法的开始；</li>
</ul>
<h3 id="安全发布对象"><a href="#安全发布对象" class="headerlink" title="安全发布对象"></a>安全发布对象</h3><p>​    多线程并发环境下，线程安全极为重要。往往一些问题的发生都是由于不正确的发布了对象造成了对象逸出而引起的，因此如果系统开发中需要发布一些对象，必须要做到安全发布，以免造成安全隐患。</p>
<ul>
<li><strong>发布对象</strong>：使一个对象能够被当前范围之外的代码所使用</li>
<li><p><strong>对象逸出</strong>：一种错误的发布情况，当一个对象还没有构造完成时，就使它被其他线程所见</p>
<pre><code>在我们的日常开发中，经常要发布一些对象，比如通过类的非私有方法返回对象的引用，或者通过公有静态变量发布对象。
</code></pre></li>
</ul>
<h4 id="发布与逸出"><a href="#发布与逸出" class="headerlink" title="发布与逸出"></a>发布与逸出</h4><h5 id="发布对象"><a href="#发布对象" class="headerlink" title="发布对象"></a>发布对象</h5><p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafePublish</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] states = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getStates() &#123;</span><br><span class="line">        <span class="keyword">return</span> states;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UnsafePublish unsafePublish = <span class="keyword">new</span> UnsafePublish();</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, Arrays.toString(unsafePublish.getStates()));</span><br><span class="line"></span><br><span class="line">        unsafePublish.getStates()[<span class="number">0</span>] = <span class="string">"d"</span>;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, Arrays.toString(unsafePublish.getStates()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[a,b,c]</span><br><span class="line">[d,b,c]</span><br></pre></td></tr></table></figure>
<p>结果分析：</p>
<p>​    以上代码通过public访问级别发布了类的域，在类的外部任何线程都可以访问这些域，这样发布对象是不安全的，因为我们无法假设，其他线程不会修改这些域，从而造成类状态的错误。</p>
<h5 id="对象逸出"><a href="#对象逸出" class="headerlink" title="对象逸出"></a>对象逸出</h5><p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="meta">@NotRecommend</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Escape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> thisCanBeEscape = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Escape</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//这里可以在Escape对象完成构造前提前引用到Escape的private变量</span></span><br><span class="line">            log.info(<span class="string">"&#123;&#125;"</span>, Escape.<span class="keyword">this</span>.thisCanBeEscape);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Escape();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类分析：</p>
<p>​    在构造对象时发生，它会使类的this引用发生逸出，从而使线程看到一个构造不完整的对象。</p>
<p>​    上面的内部类的实例包含了对封装实例隐含的引用，这样在对象没有被正确构造之前，就会被发布，有可能会有不安全因素。 </p>
<p>​    一个导致this引用在构造期间逸出的错误，是在构造函数中启动一个线程，无论是隐式启动线程，还是显式启动线程，都会造成this引用逸出，新线程总会在所属对象构造完毕前看到它。所以如果要在构造函数中创建线程，那么不要启动它，而应该采用一个专有的start或initialize方法来统一启动线程。我们可以采用工厂方法和私有构造函数来完成对象创建和监听器的注册，这样就可以避免不正确的创建。记住，我们的目的是，在对象未完成构造之前，不可以将其发布。 </p>
<h4 id="安全发布对象-1"><a href="#安全发布对象-1" class="headerlink" title="安全发布对象"></a>安全发布对象</h4><p>​    安全发布对象的四种方法：</p>
<ol>
<li>在静态初始化函数中初始化一个对象引用</li>
<li>将对象的引用保存到volatile类型域或者AtomicReference对象中</li>
<li>将对象的引用保存到某个正确构造对象的final类型域中</li>
<li>将对象的引用保存到一个由锁保护的域中</li>
</ol>
<h5 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h5><p>​    Spring 框架中，Spring管理的类都是单例模式。如何保证一个实例只被初始化一次，且线程安全？通过不同单例的写法，具体描述安全发布对象的四种方法：</p>
<h6 id="普通单例模式"><a href="#普通单例模式" class="headerlink" title="普通单例模式"></a>普通单例模式</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时进行创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可能这里会存在很多的操作</span></span><br><span class="line">        <span class="comment">//如资源加载、运算等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample1 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="comment">// 单线毫无问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//多线程环境下存在线程安全问题</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonExample1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在类装载时进行创建</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 缺点：1.若构造方法中存在过多的处理、会导加载缓慢，从而引起性能问题</span></span><br><span class="line"><span class="comment"> *       2.只进行加载，并无实际调用，导致资源浪费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample2 instance = <span class="keyword">new</span> SingletonExample2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时进行创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="meta">@NotRecommend</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample3 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="comment">//通过添加synchronized关键字，保证线程安全，但是带来了性能的开销（不希望出现的）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonExample3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonExample3();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="双重检测机制"><a href="#双重检测机制" class="headerlink" title="双重检测机制"></a>双重检测机制</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉模式 -》 双重同步锁单例模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时进行创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample4 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 双重检测机制        // B</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonExample4.class) &#123; <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonExample4(); <span class="comment">// A - 3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这样的双重检测机制是线程不安全的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1、memory = allocate() 分配对象的内存空间</span></span><br><span class="line">    <span class="comment">// 2、ctorInstance() 初始化对象</span></span><br><span class="line">    <span class="comment">// 3、instance = memory 设置instance指向刚分配的内存</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//多线程环境下</span></span><br><span class="line">    <span class="comment">// JVM和cpu优化，发生了指令重排</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、memory = allocate() 分配对象的内存空间</span></span><br><span class="line">    <span class="comment">// 3、instance = memory 设置instance指向刚分配的内存</span></span><br><span class="line">    <span class="comment">// 2、ctorInstance() 初始化对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//假设存在线程A、B同时进入双重检测机制</span></span><br><span class="line">    <span class="comment">//当线程A执行到 instance = new SingletonExample4(); // A - 执行到指令的第三步进行内存分配，但是未初始化对象</span></span><br><span class="line">    <span class="comment">//B执行到 if (instance == null) &#123; // 双重检测机制     //b发现instance不为空，直接返回对象，实上对象初始化并未开始</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉模式 -》 双重同步锁单例模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时进行创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample5</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、memory = allocate() 分配对象的内存空间</span></span><br><span class="line">    <span class="comment">// 2、ctorInstance() 初始化对象</span></span><br><span class="line">    <span class="comment">// 3、instance = memory 设置instance指向刚分配的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象 volatile + 双重检测机制 -&gt; 禁止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonExample5 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 双重检测机制        // B</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonExample5.class) &#123; <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonExample5(); <span class="comment">// A - 3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="静态域初始化"><a href="#静态域初始化" class="headerlink" title="静态域初始化"></a>静态域初始化</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在类装载时进行创建</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 静态域与静态代码块是顺序执行的，若将1 2 处位置进行交换则会出现空指针异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample6 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> SingletonExample6();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample6 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="最安全的枚举模式"><a href="#最安全的枚举模式" class="headerlink" title="最安全的枚举模式"></a>最安全的枚举模式</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举模式：最安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="meta">@Recommend</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample7</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample7</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> SingletonExample7 singleton;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JVM保证这个方法绝对只调用一次</span></span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> SingletonExample7();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程安全策略"><a href="#线程安全策略" class="headerlink" title="线程安全策略"></a>线程安全策略</h3><p>​    创建后状态不能被修改的对象叫作不可变对象。不可变对象天生就是线程安全的。它们的常量（变量）是在构造函数中创建的，既然它们的状态无法被修改，那么这些常量永远不会被改变——不可变对象永远是线程安全的。</p>
<p>不可变对象需要满足的条件</p>
<ul>
<li>对象创建以后其状态就不能修改</li>
<li>对象所有域都是final类型</li>
<li>对象是正确创建的（在对象创建期间，this引用没有逸出）</li>
</ul>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>​    final关键字：类、方法、变量</p>
<ul>
<li>修饰类：不能被继承，final类中的成员属性可以根据需要设置为final，但final类中所有的成员方法都被隐式指定为final方法。一般不建议将类设置为final类型。可以参考String类。</li>
<li>修饰方法：1）锁定方法不被继承类修改；2）效率</li>
<li>修饰变量：1）基本数据类型变量，初始化后便不能进行修改；2）引用类型变量，初始化之后不能再指向别的引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Integer a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String b = <span class="string">"2"</span>;</span><br><span class="line">    <span class="comment">//引用类型不允许引用指向改变，但是对象值还是可以进行修改的  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        a = 2;              //编译时报错</span></span><br><span class="line"><span class="comment">//        b = "3";            //编译时报错</span></span><br><span class="line"><span class="comment">//        map = Maps.newHashMap();   //编译时报错</span></span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">3</span>);       <span class="comment">//容易引发线程安全问题</span></span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, map.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以修饰参数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        a = 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h4><p>​    java提供Collections工具类，在类中提供了多种不允许修改的方法</p>
<p>​    Collections.unmodifiableXXX：Collection、List、Set、Map…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">//处理过后的map是不可以再进行修改的</span></span><br><span class="line">        map = Collections.unmodifiableMap(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//允许操作，但是操作会报错，扔出异常</span></span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, map.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collections</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">unmodifiableMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UnmodifiableMap&lt;&gt;(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnmodifiableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Guava"><a href="#Guava" class="headerlink" title="Guava"></a>Guava</h4><p>​    谷歌的Guava提供类似Java中的Collections</p>
<p>​    ImmutableXXX：Collection、List、Set、Map…</p>
<p><code>pom.xml</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>23.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableList&lt;Integer&gt; list = ImmutableList.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;Integer&gt; lists = ImmutableList.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableSet set = ImmutableSet.copyOf(list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableMap&lt;Integer, Integer&gt; map = ImmutableMap.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableMap&lt;Integer, Integer&gt; map2 = ImmutableMap.&lt;Integer, Integer&gt;builder()</span><br><span class="line">            .put(<span class="number">1</span>, <span class="number">2</span>).put(<span class="number">3</span>, <span class="number">4</span>).put(<span class="number">5</span>, <span class="number">6</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(map2.get(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程封闭</p>

      
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="index-post card" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/21/concurrency/concurrency-7/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="龙门小左">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="程序猿的日常">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2018/06/21/concurrency/concurrency-7/" itemprop="url">JAVA并发编程与高并发解决方案 - 并发编程 七</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2018-06-21T10:00:00+08:00">2018-06-21 10:00:00</time></span>
        </span>
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="JAVA并发编程与高并发解决方案-并发编程-七"><a href="#JAVA并发编程与高并发解决方案-并发编程-七" class="headerlink" title="JAVA并发编程与高并发解决方案 - 并发编程 七"></a>JAVA并发编程与高并发解决方案 - 并发编程 七</h1><table>
<thead>
<tr>
<th style="text-align:center">版本</th>
<th style="text-align:center">作者</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2018.5.8</td>
<td style="text-align:center">chuIllusions</td>
<td style="text-align:center">多线程并发拓展</td>
</tr>
</tbody>
</table>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3>
      
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="index-post card" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/21/concurrency/concurrency-6/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="龙门小左">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="程序猿的日常">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2018/06/21/concurrency/concurrency-6/" itemprop="url">JAVA并发编程与高并发解决方案 - 并发编程 六</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2018-06-21T10:00:00+08:00">2018-06-21 10:00:00</time></span>
        </span>
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="JAVA并发编程与高并发解决方案-并发编程-六"><a href="#JAVA并发编程与高并发解决方案-并发编程-六" class="headerlink" title="JAVA并发编程与高并发解决方案 - 并发编程 六"></a>JAVA并发编程与高并发解决方案 - 并发编程 六</h1><table>
<thead>
<tr>
<th style="text-align:center">版本</th>
<th style="text-align:center">作者</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2018.5.8</td>
<td style="text-align:center">chuIllusions</td>
<td style="text-align:center">线程池</td>
</tr>
</tbody>
</table>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>&emsp;&emsp;在前面使用的例子用，我们已经使用过线程池，基本上就是初始化线程池实例之后，把任务丢进去，等待调度执行就可以了，使用起来非常简单、方便。虽然使用很简单，但线程池涉及到的知识点非常多。需要分析其实现。  </p>
<p>&emsp;&emsp;JAVA中<code>Thread</code>这个类是线程类，在JAVA基础时，对于线程的认识是基于此类，为什么不使用<code>Thread</code>直接执行线程例子呢，而要使用线程池？可以试想，当并发数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。而线程池可以达到这样的效果：线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务。  </p>
<p><strong>Thread的弊端：</strong></p>
<ol>
<li>每次 <code>new Thread()</code> 新建对象，性能差；  </li>
<li>线程缺乏统一管理，可能无限制的新建线程，相互竞争，有可能占用过多系统资源导致死机或OOM；  </li>
<li>缺少更多的功能，如更多执行、定期执行、线程中断；  </li>
</ol>
<p><strong>线程池的好处</strong></p>
<ol>
<li>重用存在的线程，减少对象创建、消亡的开销，性能佳，降低资源消耗；  </li>
<li>可有效控制最大并发线程数，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞，提高响应速度；</li>
<li>提供定时执行、定期执行、单线程、并发数控制等功能，以达到提高线程的可管理性。  </li>
</ol>
<p>&emsp;&emsp;阿里发布的 Java 开发手册中强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。<br>&emsp;&emsp; <code>Executors</code>利用工厂模式向我们提供了4种线程池实现方式，但是并不推荐使用，原因是使用<code>Executors</code>创建线程池不会传入相关参数而使用默认值所以我们常常忽略了那些重要的参数（线程池大小、缓冲队列的类型等），而且默认使用的参数会导致资源浪费，不可取。</p>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><h5 id="Constructor-And-Parameters"><a href="#Constructor-And-Parameters" class="headerlink" title="Constructor And Parameters"></a>Constructor And Parameters</h5><p>&emsp;&emsp; <code>java.uitl.concurrent.ThreadPoolExecutor</code> 类是线程池中最核心的一个类，因此如果要透彻地了解Java中的线程池，必须先了解这个类，因此我们直接上源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 构造函数 1 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;&#125;</span><br><span class="line">                              </span><br><span class="line">    <span class="comment">/** 构造函数 2 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory)</span> </span>&#123;&#125;</span><br><span class="line">                              </span><br><span class="line">    <span class="comment">/** 构造函数 3 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;&#125;</span><br><span class="line">                              </span><br><span class="line">    <span class="comment">/** 构造函数 4 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp; <code>ThreadPoolExecutor</code> 类继承结构是： <code>Executor(I) &lt;- ExecutorService(I) &lt;- AbstractExecutorService(C) &lt;- TreadPoolExecutor</code>  </p>
<p>&emsp;&emsp; <code>ThreadPoolExecutor</code>类中提供了四个构造方法，在构造函数4中，参数最多，通过观察其他3个构造函数，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。</p>
<p>&emsp;&emsp;构造器中各个参数的含义：</p>
<ul>
<li><p><strong>corePoolSize</strong>： 核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了预创建线程的方法，即在没有任务到来之前就创建 corePoolSize 个线程或者 一个线程：</p>
<ul>
<li><code>prestartCoreThread()</code> :  预创建一个核心线程，使其闲置等待工作。</li>
<li><code>prestartAllCoreThreads()</code> : 启动所有核心线程，导致它们空闲地等待工作。</li>
</ul>
<p>默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；  </p>
</li>
<li><p><strong>maximumPoolSize</strong>：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；  </p>
</li>
<li><p><strong>keepAliveTime</strong>：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于<code>corePoolSize</code>时，<code>keepAliveTime</code>才会起作用，直到线程池中的线程数不大于<code>corePoolSiz</code>e，即当线程池中的线程数大于<code>corePoolSize</code>时，如果一个线程空闲的时间达到<code>keepAliveTime</code>，则会终止，直到线程池中的线程数不超过<code>corePoolSize</code>。但是如果调用了<code>allowCoreThreadTimeOut(boolean)</code>方法，在线程池中的线程数不大于<code>corePoolSize</code>时，<code>keepAliveTime</code>参数也会起作用，直到线程池中的线程数为0；  </p>
</li>
<li><p><strong>unit</strong>：参数<code>keepAliveTime</code>的时间单位，有7种取值，在<code>TimeUnit</code>类中有7种静态属性：  </p>
<ul>
<li><code>TimeUnit.DAYS</code> : 以 天 为单位 ；  </li>
<li><code>TimeUnit.HOURS</code> : 以 小时 为单位 ；  </li>
<li><code>TimeUnit.MINUTES</code> : 以 分钟 为单位 ；  </li>
<li><code>TimeUnit.SECONDS</code> : 以 秒 为单位 ；   </li>
<li><code>TimeUnit.MILLISECONDS</code> : 以 毫秒 为单位 ；   </li>
<li><code>TimeUnit.MICROSECONDS</code> : 以 微秒 为单位 ；   </li>
<li><code>TimeUnit.NANOSECONDS</code> : 以 纳秒 为单位 ；   </li>
</ul>
</li>
<li><p><strong>workQueue</strong>： 一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：  </p>
<ul>
<li><code>ArrayBlockingQueue</code>：基于数组的先进先出队列，此队列创建时必须指定大小；  </li>
<li><code>LinkedBlockingQueue</code>：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；</li>
<li><code>SynchronousQueue</code> ：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</li>
</ul>
<p>一般使用<code>LinkedBlockingQueue</code>和<code>SynchronousQueue</code>  </p>
</li>
<li><p><strong>threadFactory</strong>：线程工厂，主要用来创建线程。 线程池最主要的一项工作，就是在满足某些条件的情况下创建线程。而在<code>ThreadPoolExecutor</code>线程池中，创建线程的工作交给<code>ThreadFactory</code>来完成。要使用线程池，就必须要指定<code>ThreadFactory</code>。 如果我们使用的构造函数时并没有指定使用的<code>ThreadFactory</code>，这个时候<code>ThreadPoolExecutor</code>会使用一个默认的<code>ThreadFactory：DefaultThreadFactory</code>（这个类在Executors工具类中）;</p>
</li>
<li><p><strong>handler</strong>：在<code>ThreadPoolExecutor</code>线程池中还有一个重要的接口：<code>RejectedExecutionHandler</code>。当提交给线程池的某一个新任务无法直接被线程池中“核心线程”直接处理，又无法加入等待队列，也无法创建新的线程执行；又或者线程池已经调用<code>shutdown()</code>方法停止了工作；又或者线程池不是处于正常的工作状态；这时候<code>ThreadPoolExecutor</code>线程池会拒绝处理这个任务，触发创建<code>ThreadPoolExecutor</code>线程池时定义的<code>RejectedExecutionHandler</code>接口的实现，</p>
<p>表示当拒绝处理任务时的策略，有以下四种取值，四种值都为其静态内部类：</p>
<ul>
<li><code>ThreadPoolExecutor.AbortPolicy</code>：丢弃任务并抛出<code>RejectedExecutionException</code>异常。  </li>
<li><code>ThreadPoolExecutor.DiscardPolicy</code>：也是丢弃任务，但是不抛出异常。 </li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：丢弃队列最前面的任务，然后重新尝试执行新提交的任务。</li>
</ul>
</li>
</ul>
<h5 id="Operating-principle"><a href="#Operating-principle" class="headerlink" title="Operating principle"></a>Operating principle</h5><p>&emsp;&emsp;介绍完上面的构造函数以及其参数之后，介绍一下<code>ThreadPoolExecutor</code>的运行原理，在网上浏览到一篇相关文章，因此将它直接引用过来</p>
<blockquote>
<p><a href="https://blog.csdn.net/u010723709/article/details/50372322" target="_blank" rel="noopener">深入理解java线程池—ThreadPoolExecutor</a>，以下内容引用此文章，并且增加了自己的一点理解</p>
</blockquote>
<h6 id="ThreadPoolExecutor-execute"><a href="#ThreadPoolExecutor-execute" class="headerlink" title="ThreadPoolExecutor.execute()"></a>ThreadPoolExecutor.execute()</h6><p>&emsp;&emsp; 向线程池中提交一个不需要返回结果的任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//任务为null,则抛出异常  </span></span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//取出记录着runState和workerCount 的 ctl的当前值  </span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.第一步：</span></span><br><span class="line"><span class="comment">         * 通过workerCountOf方法从ctl所表示的int值中提取出低29位的值,也就是当前活动的线程数。</span></span><br><span class="line"><span class="comment">         * 如果当前活动的线程数少于corePoolSize,则通过addWorker(command, true)新建一个线程,并将任务(command)添加到该线程中 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2.第二步：</span></span><br><span class="line"><span class="comment">         * 2.1 isRunning(c) 当前线程池是否处于运行状态。源代码是通过判断c &lt; SHUTDOWN 来确定返回值。由于RUNNING才会接收新任务，且只有这个值-1才小于SHUTDOWN</span></span><br><span class="line"><span class="comment">         * 2.2 workQueue.offer(command) 任务添加到缓冲队列 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果 线程池已经处于非运行状态,则从缓冲队列中移除任务然后采用线程池指定的策略拒绝任务 </span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果 线程池中任务数量为0,则通过addWorker(null, false)尝试新建一个线程,新建线程对应的任务为null</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 3.第三步，也就是以上两个步骤都不满足：</span></span><br><span class="line"><span class="comment">         * 3.1 当前线程池并不处于Running状态</span></span><br><span class="line"><span class="comment">         * 3.2 当前线程池处于Running状态,但是缓冲队列已经满了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上面<code>execute()</code>方法中，出现了<code>ctl</code>，跟踪源码分析起作用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将整型的32位分为高3位和低29位，高3位表示线程池的状态,低29位表示活动的线程数  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//获得高三位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">//29位能表示的最大二进制整数，也就是活动线程数 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行状态是存储在高三位中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure></p>
<p>线程池是通过Integer类型的高3位表述当前线程池的状态RUNNING，SHUTDOWN，STOP，TIDYING，TERMINATED 。低29位表示当前线程的运行任务数量。然后通过位运算来计算运行状态和任务的数量。  </p>
<p><img src="images/threadpoolexecutor-excute.jpg" alt="execute方法处理流程"></p>
<p>&emsp;&emsp;线程池在执行<code>execute(Runnable)</code>，执行流程如下（对应图中的流程）</p>
<ol>
<li>如果当前运行的线程少于<code>corePoolSize</code>，则创建新线程来执行任务（需要获得全局锁）</li>
<li>如果运行的线程等于或多于<code>corePoolSize</code> ,则将任务加入<code>BlockingQueue</code></li>
<li>如果无法将任务加入<code>BlockingQueue</code>(队列已满)，则创建新的线程来处理任务（需要获得全局锁）</li>
<li>如果创建新线程将使当前运行的线程超出<code>maxiumPoolSize</code>，任务将被拒绝，并调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。 </li>
</ol>
<p>线程池采取上述的流程进行设计是为了减少获取全局锁的次数。在线程池完成预热（当前运行的线程数大于或等于<code>corePoolSize</code>）之后，几乎所有的<code>execute</code>方法调用都执行步骤2。</p>
<h6 id="ThreadPoolExecutor-addWorker"><a href="#ThreadPoolExecutor-addWorker" class="headerlink" title="ThreadPoolExecutor.addWorker()"></a>ThreadPoolExecutor.addWorker()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get(); <span class="comment">//获取运行状态和工作数量</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c); <span class="comment">//获取当前线程池运行的状态</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">//条件代表着以下几个场景，直接返回false说明当前工作线程创建失败</span></span><br><span class="line">        <span class="comment">//1.rs&gt;SHUTDOWN 此时不再接收新任务，且所有的任务已经执行完毕</span></span><br><span class="line">        <span class="comment">//2.rs=SHUTDOWN 此时不再接收新任务，但是会执行队列中的任务</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">//先判断当前活动的线程数是否大于最大值，如果超过了就直接返回false说明线程创建失败</span></span><br><span class="line">            <span class="comment">//如果没有超过再根据core的值再进行以下判断</span></span><br><span class="line">            <span class="comment">//1. core为true，则判断当前活动的线程数是否大于corePoolSize </span></span><br><span class="line">            <span class="comment">//2. core为false，则判断当前活动线程数是否大于maximumPoolSize</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//比较当前值是否和c相同，如果相同，则改为c+1，并且跳出大循环，直接执行Worker进行线程创建</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">//检查下当前线程池的状态是否已经发生改变</span></span><br><span class="line">            <span class="comment">//如果已经改变了，则进行外层retry大循环，否则只进行内层的循环</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//Worker的也是Runnable的实现类</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="comment">//因为不可以直接在Worker的构造方法中进行线程创建  </span></span><br><span class="line">        <span class="comment">//所以要把它的引用赋给t方便后面进行线程创建</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//上锁</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);<span class="comment">//将创建的线程添加到workers容器中  </span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">        </span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Worker</code>在<code>ThreadPoolExecutor</code>为一个内部类实现了<code>Runnable</code>接口。只有一个构造方法，在上面的<code>addWorker()</code>中<code>final Thread t = w.thread;</code>知道其实是获取了线程的对象，因为在构造方法中，线程的引用即是它自己。<br>因此在调用<code>t.start()</code>执行的是（Worker类中的方法）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里执行的是ThreadPoolExecutor中的runWorker</span></span><br><span class="line">    runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="ThreadPoolExecutor-runWorker"><a href="#ThreadPoolExecutor-runWorker" class="headerlink" title="ThreadPoolExecutor.runWorker()"></a>ThreadPoolExecutor.runWorker()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;<span class="comment">//获取Worker中的任务</span></span><br><span class="line">    w.firstTask = <span class="keyword">null</span>; <span class="comment">//将Woeker中的任务置空</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果当前任务为空  那么就从getTask中获得任务</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果task不为空，执行完task后则将task置空</span></span><br><span class="line"><span class="comment">         * 继续进入循环，则从getTask中获取任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//任务执行前调用的方法</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//任务结束后调用的方法</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以简单理解，就是执行任务，只是执行任务需要进行处理，包括获得任务、任务开始前处理、任务执行、任务执行后处理。但是，关键代码还是里面所调用的一个方法<strong><code>getTask()</code></strong>  。</p>
<p><code>beforeExecute(Thread t, Runnable r)</code>与<code>afterExecute(Runnable r, Throwable t)</code>并未在类中有处理业务的逻辑，即可以通过继承线程池的方式来重写这两个方法，这样就能够对任务的执行进行监控。</p>
<p><strong>这里我有两个疑问？</strong></p>
<ul>
<li>怎么退出这个While循环，也就是进入到<code>processWorkerExit()</code><ol>
<li>从While循环体中可以知道，当线程运行时出现异常，那么都会退出循环，进入到<code>processWorkerExit()</code>  </li>
<li>从<code>getTask()</code>获得结果为null，则也会进到<code>processWorkerExit()</code> </li>
</ol>
</li>
</ul>
<ul>
<li>getTask()方法为什么是最关键的？分析其执行代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line">    <span class="comment">//死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">//如果设置了allowCoreThreadTimeOut(true)</span></span><br><span class="line">        <span class="comment">//或者当前运行的任务数大于设置的核心线程数</span></span><br><span class="line">        <span class="comment">// timed = true</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** ------------------------以上的操作跟之前类似----------------------- */</span></span><br><span class="line">        <span class="comment">/** ------------------------关键在于下面的代码------------------------- */</span></span><br><span class="line">        <span class="comment">/** ------------------------从阻塞队列中获取任务----------------------- */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                <span class="comment">//对于阻塞队列，poll(long timeout, TimeUnit unit) 将会在规定的时间内去任务</span></span><br><span class="line">                <span class="comment">//如果没取到就返回null</span></span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                <span class="comment">//take会一直阻塞，等待任务的添加</span></span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>到此，终于发现为什么线程池能够保证一直等待任务而不被销毁，其实就是进入了阻塞状态。</strong></p>
<h6 id="ThreadPoolExecutor-processWorkerExit"><a href="#ThreadPoolExecutor-processWorkerExit" class="headerlink" title="ThreadPoolExecutor.processWorkerExit()"></a>ThreadPoolExecutor.processWorkerExit()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> completedAbruptly 工作线程是否死与执行任务出现的异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">//如果突然被打断，工作线程数不会被减少</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//判断运行状态是否在STOP之前</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;<span class="comment">//正常退出，也就是task == null</span></span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新增一个工作线程，代替原来的工作线程</span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="AbstractExecutorService-submit"><a href="#AbstractExecutorService-submit" class="headerlink" title="AbstractExecutorService.submit()"></a>AbstractExecutorService.submit()</h6><p>&emsp;&emsp; 向线程池中提交一个需要返回结果的任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>ThreadPoolExecutor</code>中并未发现<code>submit()</code>，因此从父类，即抽象类<code>AbstractExecutorService</code>中找到<code>submit()</code>的方法实现，从方法实现中，可知：</p>
<ol>
<li><code>submit()</code>接收任务参数，并将参数封装为<code>FutureTask</code>任务类  </li>
<li>将封装好的<code>FutureTask</code>提交到<code>execute()</code>中  </li>
</ol>
<p><strong>结论：</strong><code>submit()</code>真正实现的任务处理流程跟<code>execute()</code>一样，也可以说<code>submit()</code>就是调用了<code>execute()</code></p>
<p><img src="images/threadpoolexecutor-1.jpg" alt="线程池的处理流程"></p>
<p>&emsp;&emsp;从上面的流程图可以知道，向线程池提交一个任务后，共经历以下流程：</p>
<ol>
<li>提交任务到线程池；  </li>
<li>线程池判断核心线程池里是的线程是否都在执行任务，如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下一个流程。  </li>
<li>线程池判断工作队列是否已满。如果工作队列没有满，则将新提交的任务储存在这个工作队列里。如果工作队列满了，则进入下一个流程。</li>
<li>线程池判断其内部线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已满了，则交给饱和策略来处理这个任务。</li>
</ol>
<h6 id="ThreadPoolExecutor-shutdown"><a href="#ThreadPoolExecutor-shutdown" class="headerlink" title="ThreadPoolExecutor.shutdown()"></a>ThreadPoolExecutor.shutdown()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();<span class="comment">//检查终止线程池的线程是否有权限。  </span></span><br><span class="line">        advanceRunState(SHUTDOWN);<span class="comment">// 设置线程池的状态为关闭状态。  </span></span><br><span class="line">        interruptIdleWorkers();<span class="comment">// 中断线程池中空闲的线程</span></span><br><span class="line">        onShutdown(); <span class="comment">// 钩子函数，在ThreadPoolExecutor中没有任何动作 </span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();<span class="comment">// 尝试终止线程池  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="index-post card" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/21/concurrency/concurrency-5/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="龙门小左">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="程序猿的日常">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2018/06/21/concurrency/concurrency-5/" itemprop="url">JAVA并发编程与高并发解决方案 - 并发编程 五</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2018-06-21T10:00:00+08:00">2018-06-21 10:00:00</time></span>
        </span>
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="JAVA并发编程与高并发解决方案-并发编程-五"><a href="#JAVA并发编程与高并发解决方案-并发编程-五" class="headerlink" title="JAVA并发编程与高并发解决方案 - 并发编程 五"></a>JAVA并发编程与高并发解决方案 - 并发编程 五</h1><table>
<thead>
<tr>
<th style="text-align:center">版本</th>
<th style="text-align:center">作者</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2018.5.8</td>
<td style="text-align:center">chuIllusions</td>
<td style="text-align:center">J.U.C组件拓展</td>
</tr>
</tbody>
</table>
<h3 id="J-U-C-组件拓展"><a href="#J-U-C-组件拓展" class="headerlink" title="J.U.C 组件拓展"></a>J.U.C 组件拓展</h3><h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><h5 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h5><p>&emsp;&emsp;<code>FutureTask</code>这个组件是J.U.C里面的，但不是AQS的子类，但是这个类对线程处理的结果很值得我们学习和在项目中使用。<br>&emsp;&emsp;在Java中一般通过继承Thread类或者实现Runnable接口这两种方式来创建多线程，但是这两种方式都有个缺陷，就是不能在执行完成后获取执行的结果，在Java 1.5之后提供了Callable和Future接口，通过它们就可以在任务执行完毕之后得到任务的执行结果。  </p>
<h5 id="Callable-与-Runnable"><a href="#Callable-与-Runnable" class="headerlink" title="Callable 与 Runnable"></a>Callable 与 Runnable</h5><p><code>Callable</code>接口定义，运行<code>Callable</code>任务可以拿到一个Future对象，表示异步计算的结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果或失败时扔出异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 计算失败扔出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Runnable</code>接口定义，由于<code>run()</code>方法返回值为<code>void</code>类型，所以在执行完任务之后无法返回任何结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当一个对象实现&lt;code&gt;Runnable&lt;/code&gt;接口创建一个线程，这个对象通过覆写</span></span><br><span class="line"><span class="comment">     * run方法处理线程逻辑，并且Thread类启动该线程，执行Runnable处理线程逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&amp;emsp可以看到<code>Callable</code>是个泛型接口，泛型V就是要call()方法返回的类型。<code>Callable</code>接口和<code>Runnable</code>接口很像，都可以被另外一个线程执行，<code>Callable</code>功能更强大些，正如前面所说的，<code>Runnable</code>不会返回数据也不能抛出异常，而<code>Callable</code>可以有返回值与可以抛出异常。  </p>
<h5 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h5><p>&emsp;&emsp;<code>Future</code>接口代表异步计算的结果，通过Future接口提供的方法可以查看异步计算是否执行完成，或者等待执行结果并获取执行结果，同时还可以取消执行。也就是说<code>Future</code>就是对于具体的<code>Runnable</code>或者<code>Callable</code>任务的执行结果进行取消、查询是否完成、获取结果。通常不能从线程中获得方法的返回值，这时<code>Future</code>就出场了，<code>Future</code>可以监控目标线程调用<code>call()</code>的情况。总结来说，<code>Future</code>可以得到线程任务方法的返回值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 取消异步任务的执行。</span></span><br><span class="line"><span class="comment">     * 如果异步任务已经完成或者已经被取消，或者由于某些原因不能取消，则会返回false；</span></span><br><span class="line"><span class="comment">     * 如果任务还没有被执行，则会返回true并且异步任务不会被执行；</span></span><br><span class="line"><span class="comment">     * 如果任务已经开始执行了但是还没有执行完成：</span></span><br><span class="line"><span class="comment">     * 		若mayInterruptIfRunning为true，则会立即中断执行任务的线程并返回true</span></span><br><span class="line"><span class="comment">     * 		若mayInterruptIfRunning为false，则会返回true且不会中断任务执行线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 判断任务是否被取消，如果任务在结束(正常执行结束或者执行异常结束)前被取消则返回true，否则返回false。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 判断任务是否已经完成，如果完成则返回true，否则返回false。需要注意的是：任务执行过程中发生异常、任务被取消也属于任务已完成，也会返回true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取任务执行结果:</span></span><br><span class="line"><span class="comment">     * 		如果任务还没完成则会阻塞等待直到任务执行完成</span></span><br><span class="line"><span class="comment">     * 		如果任务被取消则会抛出CancellationException异常</span></span><br><span class="line"><span class="comment">     * 		如果任务执行过程发生异常则会抛出ExecutionException异常</span></span><br><span class="line"><span class="comment">     * 		如果阻塞等待过程中被中断则会抛出InterruptedException异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 带超时时间的get()版本，如果阻塞等待过程中超时则会抛出TimeoutException异常。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的<code>FutureTask</code>。  </p>
<h5 id="FutureTask-1"><a href="#FutureTask-1" class="headerlink" title="FutureTask"></a>FutureTask</h5><p>&emsp;&emsp;<code>Future</code>只是一个接口，不能直接用来创建对象，<code>FutureTask</code>是<code>Future</code>的实现类。  </p>
<p><code>public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {}</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;从上面两个类结构，可以得知<code>FutureTask</code>最终还是执行<code>Callable</code>类型的任务。如果在<code>FutureTask</code>构造函数中传入<code>Runnable</code>，会转换成<code>Callable</code>类型。  </p>
<p>&emsp;&emsp;<code>FutureTask</code>实际上实现了<code>Runnable</code>与<code>Future</code>接口，所以它既可以作为<code>Runnable</code>被线程执行，又可以作为<code>Future</code>得到<code>Callable</code>的返回值。好处：假设有个很费时的逻辑需要计算，并且返回这个计算值，同时这个值又不是马上需要，那么就可以使用这个组合，用另外一个线程计算返回值，而当前线程在使用这个返回值之前，可以做其他的操作，等到需要这个返回值时，才通过<code>Future</code>得到。  </p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Callable任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            log.info(<span class="string">"do something in callable"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Done"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.生成线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//线程池提交Callable任务，并且得到Future</span></span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> MyCallable());</span><br><span class="line">        log.info(<span class="string">"do something in main"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//调用Future.get()时，如果任务线程还未执行完毕，则会一直阻塞在此，等待线程任务完成，然后拿到结果</span></span><br><span class="line">        String result = future.get();</span><br><span class="line">        log.info(<span class="string">"result：&#123;&#125;"</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上<code>Future</code>与以下<code>FutureTask</code>要实现的效果是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                log.info(<span class="string">"do something in callable"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Done"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        log.info(<span class="string">"do something in main"</span>);</span><br><span class="line">        <span class="comment">// 1. 调用isDone()判断任务是否结束</span></span><br><span class="line">        <span class="keyword">if</span>(!futureTask.isDone()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Task is not done"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//阻塞主线程一秒钟</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String result = futureTask.get();</span><br><span class="line">        log.info(<span class="string">"result：&#123;&#125;"</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考<a href="http://www.importnew.com/25286.html" target="_blank" rel="noopener">深入学习 FutureTask</a></p>
</blockquote>
<h4 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h4><h5 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h5><p>&emsp;&emsp;Fork/Join框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。它的思想与<code>MapReduce</code>类似，从字面上理解，Fork即把一个大任务，切割成若干个子任务并行执行，Join即把若干个子任务结果进行合并，最后得到大任务的结果，主要采取工作窃取算法。<br>&emsp;&emsp;工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。<br><img src="images/forkjoin-1.png" alt="Fork/Join框架流程图"><br>&emsp;&emsp;假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。  </p>
<p>&emsp;&emsp;工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。  </p>
<p>&emsp;&emsp;对于Fork/Join框架而言，当一个任务正在等待它使用Join操作创建的子任务结束时，执行这个任务的工作线程，寻找其他并未被执行的任务，并开始执行，通过这种方式，线程充分利用它们的运行时间，来提高应用程序的性能。为了实现这个目标，Fork/Join框架执行的任务有一些<strong>局限性：</strong></p>
<ol>
<li>任务只能使用Fork、Join操作来作为同步机制，如果使用了其他同步机制，那他们在同步操作时，工作线程则不能执行其他任务。如：在框架的操作中，使任务进入睡眠，那么在这个睡眠期间内，正在执行这个任务的工作线程，将不会执行其他任务</li>
<li>所执行的任务，不应该执行IO操作，如读和写数据文件</li>
<li>任务不能抛出检查型异常，必须通过必要的代码处理它们</li>
</ol>
<p>核心是两个类：<code>ForkJoinTask</code>与<code>ForkJoinPool</code>。Pool主要负责实现，包括上面所介绍的工作窃取算法，管理工作线程和提供关于任务的状态以及它们的执行信息；Task主要提供在任务中，执行Fork与Join操作的机制。  </p>
<blockquote>
<p>引用[<a href="https://www.cnblogs.com/zhaobingqing/p/7217781.html" target="_blank" rel="noopener">并行流与串行流 Fork/Join框架</a>的一张图来说明过程</p>
</blockquote>
<p><img src="images/forkjoin-2.png" alt="fork/join过程图"></p>
<h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><p>我们先来看一下Fork/Join框架的演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="comment">//Recursive递归的意思,把大任务不断的拆分成小任务，即是一个递归拆分任务的一个过程</span></span><br><span class="line"><span class="comment">//RecursiveTask&lt;T&gt;,T表示任务的返回值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTaskExample</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">//设置分割的阈值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinTaskExample</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果任务足够小就计算任务</span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (end - start) &lt;= threshold;</span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="comment">//任务足够小的时候，直接计算，不进行分裂计算</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 下面可能会产生递归操作</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//继续分裂任务</span></span><br><span class="line">            ForkJoinTaskExample leftTask = <span class="keyword">new</span> ForkJoinTaskExample(start, middle);</span><br><span class="line">            ForkJoinTaskExample rightTask = <span class="keyword">new</span> ForkJoinTaskExample(middle + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待任务执行结束合并其结果</span></span><br><span class="line">            <span class="keyword">int</span> leftResult = leftTask.join();</span><br><span class="line">            <span class="keyword">int</span> rightResult = rightTask.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并子任务</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生成一个池</span></span><br><span class="line">        ForkJoinPool forkjoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成一个计算任务，计算1+2+3+4</span></span><br><span class="line">        ForkJoinTaskExample task = <span class="keyword">new</span> ForkJoinTaskExample(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行一个任务，将任务放入池中，并开始执行，并用Future接收</span></span><br><span class="line">        Future&lt;Integer&gt; result = forkjoinPool.submit(task);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"result:&#123;&#125;"</span>, result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过这个例子让我们再来进一步了解<code>ForkJoinTask</code>，任务类继承<code>RecursiveTask</code>，<code>ForkJoinTask</code>与一般的任务的主要区别在于它需要实现<code>compute()</code>方法，在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果不足够小，就必须分割成两个子任务，每个子任务在调用<code>fork()</code>方法时，又会进入<code>compute()</code>方法，看看当前子任务是否需要继续分割成孙任务，如果不需要继续分割，则执行当前子任务并返回结果。使用<code>join()</code>方法会等待子任务执行完并得到其结果。  </p>
<h5 id="Main-Class"><a href="#Main-Class" class="headerlink" title="Main Class"></a>Main Class</h5><p>&emsp;&emsp;上面提到，Fork/Join框架中的两个核心类<code>ForkJoinTask</code>与<code>ForkJoinPool</code>，并且从上面的例子可以知道，声明<code>ForkJoinTask</code>后，将其加入到<code>ForkJoinPool</code>中，并返回一个<code>Future</code>对象。  </p>
<ul>
<li><code>ForkJoinPool</code> ：<code>ForkJoinTask</code>需要通过<code>ForkJoinPool</code>来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</li>
<li><code>ForkJoinTask</code>：我们要使用<code>ForkJoin</code>框架，必须首先创建一个<code>ForkJoin</code>任务。它提供在任务中执行<code>fork()</code>和<code>join()</code>操作的机制，通常情况下我们不需要直接继承<code>ForkJoinTask</code>类，而只需要继承它的子类，<code>Fork/Join</code>框架提供了以下两个子类：<ul>
<li><code>RecursiveAction</code>：用于没有返回结果的任务。</li>
<li><code>RecursiveTask</code> ：用于有返回结果的任务。</li>
</ul>
</li>
</ul>
<p><img src="images/forkjoin-4.png" alt="ForkJoin相关类"></p>
<h5 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h5><p>&emsp;&emsp;<code>ForkJoinTask</code>在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以<code>ForkJoinTask</code>提供了<code>isCompletedAbnormally()</code>方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过<code>ForkJoinTask</code>的<code>getException()</code>方法获取异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** ForkJoinTask运行状态 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> status; <span class="comment">// 直接被ForkJoin池和工作线程访问</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DONE_MASK   = <span class="number">0xf0000000</span>;  <span class="comment">// mask out non-completion bits</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL      = <span class="number">0xf0000000</span>;  <span class="comment">// must be negative</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED   = <span class="number">0xc0000000</span>;  <span class="comment">// must be &lt; NORMAL</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL = <span class="number">0x80000000</span>;  <span class="comment">// must be &lt; CANCELLED</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL      = <span class="number">0x00010000</span>;  <span class="comment">// must be &gt;= 1 &lt;&lt; 16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SMASK       = <span class="number">0x0000ffff</span>;  <span class="comment">// short bits for tags</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Ruturn</span> 任务是否扔出异常或被取消</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isCompletedAbnormally</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status &lt; NORMAL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果计算扔出异常，则返回异常</span></span><br><span class="line"><span class="comment">     * 如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Throwable <span class="title">getException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = status &amp; DONE_MASK;</span><br><span class="line">        <span class="keyword">return</span> ((s &gt;= NORMAL)    ? <span class="keyword">null</span> :</span><br><span class="line">                (s == CANCELLED) ? <span class="keyword">new</span> CancellationException() :</span><br><span class="line">                getThrowableException());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h5><h6 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ForkJoinPool，它同ThreadPoolExecutor一样，也实现了Executor和ExecutorService接口。它使用了</span></span><br><span class="line"><span class="comment">     * 一个无限队列来保存需要执行的任务，而线程的数量则是通过构造函数传入，如果没有向构造函数中传入希</span></span><br><span class="line"><span class="comment">     * 望的线程数量，那么当前计算机可用的CPU数量会被设置为线程数量作为默认值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Math.min(MAX_CAP,Runtime.getRuntime().availableProcessors()),</span><br><span class="line">             defaultForkJoinWorkerThreadFactory, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(parallelism, defaultForkJoinWorkerThreadFactory, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有多个构造器，这里省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">volatile</span> WorkQueue[] workQueues;     <span class="comment">// main registry</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkQueue</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ForkJoinWorkerThread owner; <span class="comment">// 工作线程</span></span><br><span class="line">        ForkJoinTask&lt;?&gt;[] array;   <span class="comment">// 任务</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//传入的是ForkJoinPool与指定的一个工作线程</span></span><br><span class="line">        WorkQueue(ForkJoinPool pool, ForkJoinWorkerThread owner) &#123;</span><br><span class="line">            <span class="keyword">this</span>.pool = pool;</span><br><span class="line">            <span class="keyword">this</span>.owner = owner;</span><br><span class="line">            <span class="comment">// Place indices in the center of array (that is not yet allocated)</span></span><br><span class="line">            base = top = INITIAL_QUEUE_CAPACITY &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>ForkJoinPool</code>中源码挺强大的，我只抽取了重要的部分进行分析。</p>
<ul>
<li><code>ForkJoinPool</code>中维护了一组<code>WorkQueue</code>，也就是工作队列，工作队列中又维护了一个工作线程<code>ForkJoinWorkerThread</code>与一组工作任务<code>ForkJoinTask</code>  </li>
<li><code>WorkQueue</code>是一个双端队列（Deque），即 Double Ended Queue ，Deque是一种具有队列和栈的性质的数据结构，双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行。  </li>
<li>每个工作线程在运行中产生新的任务（通常是因为调用了<code>fork()</code>）时，会放入工作队列的队尾，并且工作线程在处理自己的工作队列时，使用的是<code>LIFO</code> 方式，也就是说每次从队尾取出任务来执行。  </li>
<li>每个工作线程在处理自己的工作队列同时，会尝试窃取一个任务（或是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的工作队列），窃取的任务位于其他线程的工作队列的队首，也就是说工作线程在窃取其他工作线程的任务时，使用的是 FIFO 方式。  </li>
<li>在遇到 join() 时，如果需要 join 的任务尚未完成，则会先处理其他任务，并等待其完成。</li>
<li>在既没有自己的任务，也没有可以窃取的任务时，进入休眠。  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">ForkJoinTask&lt;T&gt; <span class="title">submit</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">ForkJoinTask&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">ForkJoinTask&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> ForkJoinTask&lt;?&gt; submit(Runnable task) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面来看，<code>ForkJoinPool</code>所提供的<code>submit()</code>方法中，有几个重载。</p>
<p><code>ForkJoinPool</code>自身也拥有工作队列，这些工作队列的作用是用来接收由外部线程（非 <code>ForkJoinThread</code> 线程）提交过来的任务，而这些工作队列被称为 <code>submitting queue</code> 。</p>
<h6 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h6><p>&emsp;&emsp;从上面的例子，我们可以知道，任务的操作，重要的是<code>fork()</code> 和  <code>join()</code>，我们可以假设这两个的作用：  </p>
<ul>
<li><code>fork()</code>：开启一个新线程（或是重用线程池内的空闲线程），将任务交给该线程处理。  </li>
<li><code>join()</code>：等待该任务的处理线程处理完毕，获得返回值。</li>
</ul>
<p>&emsp;&emsp;但对我的这个假设，很明显就不对的，当任务分解得越来越细时，所需要的线程数就会越来越多，而且大部分线程处于等待状态。从<code>ForkJoinPool</code>的构造函数中，可以知道，工作线程的数量是指定的，或者说是按照系统默认的。<br>&emsp;&emsp;可以得出，我的假设是错误的，因此，并不是每个 fork() 都会促成一个新线程被创建，而每个 join() 也不是一定会造成线程被阻塞。这一点可以体现出<code>work stealing 算法</code>的优势。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在当前任务正在运行的池中异步执行此任务（如果适用）</span></span><br><span class="line"><span class="comment">     * 或使用ForkJoinPool.commonPool()（如果不是ForkJoinWorkerThread实例）进行异步执行 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">            ((ForkJoinWorkerThread)t).workQueue.push(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ForkJoinPool.common.externalPush(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        <span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">            reportException(s);</span><br><span class="line">        <span class="keyword">return</span> getRawResult();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">        <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :</span><br><span class="line">            ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">            (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">            tryUnpush(<span class="keyword">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">            wt.pool.awaitJoin(w, <span class="keyword">this</span>, <span class="number">0L</span>) :</span><br><span class="line">            externalAwaitDone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>fork()</code> 做的工作只有一件事，既是把任务推入当前工作线程的工作队列里。</li>
<li><code>join()</code> 的工作则复杂得多，也是<code>join()</code> 可以使得线程免于被阻塞的原因  <ol>
<li>检查调用 <code>join()</code> 的线程是否是 <code>ForkJoinThread</code> 线程。如果不是（例如 main 线程），则阻塞当前线程，等待任务完成。如果是，则不阻塞。</li>
<li>查看任务的完成状态，如果已经完成，直接返回结果。</li>
<li>如果任务尚未完成，但处于自己的工作队列内，则完成它。</li>
<li>如果任务已经被其他的工作线程偷走，则窃取这个小偷的工作队列内的任务（以 FIFO 方式），执行，以期帮助它早日完成欲 join 的任务。</li>
<li>如果偷走任务的小偷也已经把自己的任务全部做完，正在等待需要 join 的任务时，则找到小偷的小偷，帮助它完成它的任务。</li>
<li>递归地执行第5步。</li>
</ol>
</li>
</ol>
<p><img src="images/forkjoin-3.png" alt="join()流程图"></p>
<blockquote>
<p>以上部分内容引用于<a href="http://blog.dyngr.com/blog/2016/09/15/java-forkjoinpool-internals/" target="_blank" rel="noopener">Java 并发编程笔记：如何使用 ForkJoinPool 以及原理</a></p>
</blockquote>
<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><blockquote>
<p>引用一篇相关文章的一段话，初探BlockingQueue：<a href="https://www.cnblogs.com/KingIceMou/p/8075343.html" target="_blank" rel="noopener">BlockingQueue</a><br>&emsp;&emsp;多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。然而，在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。好在此时，强大的concurrent包横空出世了，而他也给我们带来了强大的BlockingQueue。（在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤醒）</p>
</blockquote>
<p><img src="images/blockingqueue-1.png" alt="BlockingQueue示意图"></p>
<p>&emsp;&emsp;<code>BlockingQueue</code>即为阻塞队列，是一个先进先出的队列，在某些情况下，对阻塞队列的访问可能会造成阻塞，被阻塞的情况主要有两种：</p>
<ol>
<li>当队列满时，进行入队列操作。当一个线程试图对一个已经满了的队列进行入队操作时， 他将会阻塞，除非有另一个线程做了出队列的操作。  </li>
<li>当队列空时，进行出队列操作。当一个线程试图对一个空队列进行出队操作时，他也将会被阻塞，除非有另一个线程做了入队的操作。  </li>
</ol>
<p>&emsp;&emsp;阻塞队列是线程安全的，主要用在生产者与消费者的场景。上图就是线程生产和消费的场景，负责生产的线程不断的制造新对象并插入到阻塞队列中，直到达到队列的上限值，从而被阻塞，直到消费线程对队列进行消费。同理，负责消费的线程不断的从队列中消费对象，直到这个队列为空，这时消费线程将会被阻塞，除非队列中有新的队列被生产加入。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>BlockingQueue</code> 是一个接口，继承自 <code>Queue</code>，所以其实现类也可以作为 <code>Queue</code> 的实现来使用，而 <code>Queue</code> 又继承自 <code>Collection</code> 接口。</p>
<p>&emsp;&emsp;<code>BlockingQueue</code>对插入操作、移除操作、获取元素操作提供了四种不同的方法用于不同的场景中使用。我们使用不同的方法，都会有不同的表现。<code>BlockingQueue</code> 的各个实现都遵循了这些规则：</p>
<table>
<thead>
<tr>
<th></th>
<th>Throws Exception</th>
<th>Special Value</th>
<th>Blocks</th>
<th>Times Out</th>
</tr>
</thead>
<tbody>
<tr>
<td>insert</td>
<td>add(o)</td>
<td>offer(o)</td>
<td>put(o)</td>
<td>offer(o,timeout,timeunit)</td>
</tr>
<tr>
<td>remove</td>
<td>remove(o)</td>
<td>poll()</td>
<td>take()</td>
<td>poll(timeout,timeunit)</td>
</tr>
<tr>
<td>examine</td>
<td>element()</td>
<td>peek()</td>
<td>not applicable</td>
<td>not applicable</td>
</tr>
</tbody>
</table>
<ol>
<li>Throws Exception：抛出异常。如果不能马上进行，则抛出异常。  </li>
<li>Special Value：如果不能马上进行，则返回特殊值，一般是True或False  </li>
<li>Blocks：如果不能马上进行，则操作会被阻塞，直到这个操作成功  </li>
<li>Times Out：如果不能马上进行，操作会被阻塞指定的时间。如果指定时间还未执行，则返回特殊值，一般是True或False。  </li>
</ol>
<p>对于<code>BlockingQueue</code>，关注点应该在它的<code>put</code>和<code>take</code>方法上，因为这两个方法是带阻塞的。  </p>
<p>&emsp;&emsp;<code>BlockingQueue</code> 不接受 <code>null</code> 值的插入，相应的方法在碰到<code>null</code> 的插入时会抛出 <code>NullPointerException</code> 异常。<code>null</code> 值在这里通常用于作为特殊值返回（表格中的第三列），代表 <code>poll</code> 失败。所以，如果允许插入 <code>null</code> 值的话，那获取的时候，就不能很好地用 <code>null</code> 来判断到底是代表失败，还是获取的值就是 <code>null</code> 值。  </p>
<p>&emsp;&emsp;前面说了，它实现了 <code>java.util.Collection</code> 接口。例如，我们可以用 <code>remove(x)</code> 来删除任意一个元素，但是，这类操作通常并不高效，所以尽量只在少数的场合使用，比如一条消息已经入队，但是需要做取消操作的时候。  </p>
<p>&emsp;&emsp;<code>BlockingQueue</code> 的实现都是线程安全的，但是批量的集合操作如 <code>addAll</code>, <code>containsAll</code>, <code>retainAll</code> 和 <code>removeAll</code> 不一定是原子操作。如 <code>addAll(c)</code> 有可能在添加了一些元素后中途抛出异常，此时 <code>BlockingQueue</code> 中已经添加了部分元素，这个是允许的，取决于具体的实现。  </p>
<p>&emsp;&emsp;<code>BlockingQueue</code> 在生产者-消费者的场景中，是支持多消费者和多生产者的，说的其实就是线程安全问题。<code>BlockingQueue</code> 是一个比较简单的线程安全容器。作为<code>BlockingQueue</code>的使用者，我们再也不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切<code>BlockingQueue</code>都给你一手包办了。  </p>
<p>&emsp;&emsp;这里补充一点，一般所说的无界队列，并不是大小不限制的，只是它的大小是<code>Integer.MAX_VALUE</code>，即int类型能够表示的最大值，也可以理解为大小是<strong>(2的31次方)-1</strong></p>
<p><code>BlockingQueue</code>家庭中实现类主要有以下几个，常用的是<code>ArrayBlockingQueue</code>与<code>LinkedBlockingQueue</code>，下文将会对这两个类作详细介绍。其他成员将简单介绍。</p>
<ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
<li>DelayQueue：</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue</li>
</ul>
<blockquote>
<p>参考：<a href="http://www.importnew.com/28053.html" target="_blank" rel="noopener">解读 Java 并发队列 BlockingQueue</a></p>
</blockquote>
<h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h5><h6 id="Introdution"><a href="#Introdution" class="headerlink" title="Introdution"></a>Introdution</h6><p>&emsp;&emsp;有界的阻塞队列，内部实现是一个数组，有边界的意思是：容量是有限的，必须初始化时，指定它的容量大小，以先进先出的方式存储数据，最新插入的对象在尾部，最先移除的对象在头部。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 队列元素 */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 下一次读取操作的位置, poll, peek or remove */</span></span><br><span class="line">    <span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 下一次写入操作的位置, offer, or add */</span></span><br><span class="line">    <span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 元素数量 */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Concurrency control uses the classic two-condition algorithm</span></span><br><span class="line"><span class="comment">     * found in any textbook.</span></span><br><span class="line"><span class="comment">     * 它采用一个 ReentrantLock 和相应的两个 Condition 来实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Main lock guarding all access */</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Condition for waiting takes */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Condition for waiting puts */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 指定大小 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 指定容量大小与指定访问策略 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fair 指定独占锁是公平锁还是非公平锁。非公平锁的吞吐量比较高，公平锁可以保证每次都是等待最久的线程获取到锁；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 指定容量大小、指定访问策略与最初包含给定集合中的元素 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 将此集合中的元素在构造方法期间就先添加到队列中 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Collection&lt;? extends E&gt; c)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的类结构，可以知道：</p>
<ol>
<li><code>ArrayBlockingQueue</code> 在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行。按照实现原理来分析，<code>ArrayBlockingQueue</code>完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为<code>ArrayBlockingQueue</code>的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。   </li>
<li>通过构造函数得知，参数<code>fair</code>控制对象的内部锁是否采用公平锁，默认采用非公平锁。  </li>
<li>items、takeIndex、putIndex、count等属性并没有使用volatile修饰，这是因为访问这些变量（通过方法获取）使用都是在锁块内，并不存在可见性问题，如<code>size()</code>  </li>
<li>另外有个独占锁lock用来对出入队操作加锁，这导致同时只有一个线程可以访问入队出队。  </li>
</ol>
<h6 id="Put"><a href="#Put" class="headerlink" title="Put()"></a>Put()</h6><p>&emsp;&emsp;我们通过源码，分析一下<code>Put</code>方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 进行入队操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//e为null，则抛出NullPointerException异常</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">//获取独占锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lockInterruptibly()</span></span><br><span class="line"><span class="comment">     * 获取锁定，除非当前线程为interrupted</span></span><br><span class="line"><span class="comment">     * 如果锁没有被另一个线程占用并且立即返回，则将锁定计数设置为1。</span></span><br><span class="line"><span class="comment">     * 如果当前线程已经保存此锁，则保持计数将递增1，该方法立即返回。</span></span><br><span class="line"><span class="comment">     * 如果锁被另一个线程保持，则当前线程将被禁用以进行线程调度，并且处于休眠状态</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//空队列</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            <span class="comment">//进行条件等待处理</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        <span class="comment">//入队操作</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 真正的入队 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="comment">//获取当前元素</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="comment">//按下一个插入索引进行元素添加</span></span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="comment">// 计算下一个元素应该存放的下标，可以理解为循环队列</span></span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">//唤起消费者</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这里由于在操作共享变量前加了锁，所以不存在内存不可见问题，加过锁后获取的共享变量都是从主内存获取的，而不是在CPU缓存或者寄存器里面的值，释放锁后修改的共享变量值会刷新会主内存中。  </p>
<p>&emsp;&emsp;另外这个队列是使用循环数组实现，所以计算下一个元素存放下标时候有些特殊。另外<code>insert</code>后调用 <code>notEmpty.signal();</code>是为了激活调用<code>notEmpty.await();</code>阻塞后放入<code>notEmpty</code>条件队列中的线程。  </p>
<h6 id="Take"><a href="#Take" class="headerlink" title="Take()"></a>Take()</h6><p>&emsp;&emsp;我们通过源码，分析一下<code>take</code>方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="comment">//这里有些特殊</span></span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//保持队列中的元素和迭代器的元素一致</span></span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;从上面分析可以知道，其实<code>Put</code>操作与<code>Take</code>操作很相似。但是有一点我在上面代码中标识了，继续深入了解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该类的迭代器，所有的迭代器共享数据，队列改变会影响所有的迭代器</span></span><br><span class="line"><span class="keyword">transient</span> Itrs itrs = <span class="keyword">null</span>; <span class="comment">//其存放了目前所创建的所有迭代器。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 迭代器和它们的队列之间的共享数据，允许队列元素被删除时更新迭代器的修改。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Itrs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">elementDequeued</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//队列中数量为0的时候，队列就是空的，会将所有迭代器进行清理并移除</span></span><br><span class="line">            queueIsEmpty();</span><br><span class="line">        <span class="comment">//takeIndex的下标是0，意味着队列从尾中取完了，又回到头部获取</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (takeIndex == <span class="number">0</span>)</span><br><span class="line">            takeIndexWrapped();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当队列为空的时候做的事情</span></span><br><span class="line"><span class="comment">     * 1. 通知所有迭代器队列已经为空</span></span><br><span class="line"><span class="comment">     * 2. 清空所有的弱引用，并且将迭代器置空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">queueIsEmpty</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将takeIndex包装成0</span></span><br><span class="line"><span class="comment">     * 并且通知所有的迭代器，并且删除已经过期的任何对象（个人理解是置空对象）</span></span><br><span class="line"><span class="comment">     * 也直接的说就是在Blocking队列进行出队的时候，进行迭代器中的数据同步，保持队列中的元素和迭代器的元素是一致的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">takeIndexWrapped</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分析到这里，就有个疑问了，这个迭代器到底是什么时候生成的呢？而且他在出队时，是判断了迭代器不为空的时候才进行操作，而肯定会存在一种情况，那就是迭代器是空的，并未创建，则不进行操作。</p>
<p>通过在源码奔走，我找到了相关内容，如下，还是在我们的<code>ArrayBlockingQueue</code>的源码中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从这里知道，在ArrayBlockingQueue对象中调用此方法，才会生成这个对象</span></span><br><span class="line"><span class="comment">//那么就可以理解为，只要并未调用此方法，则ArrayBlockingQueue对象中的Itrs对象则为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    Itr() &#123;</span><br><span class="line">        <span class="comment">//这里就是生产它的地方</span></span><br><span class="line">        <span class="comment">//count等于0的时候，创建的这个迭代器是个无用的迭代器，可以直接移除，进入detach模式。</span></span><br><span class="line">        <span class="comment">//否则就把当前队列的读取位置给迭代器当做下一个元素，cursor存储下个元素的位置。</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// assert itrs == null;</span></span><br><span class="line">            cursor = NONE;</span><br><span class="line">            nextIndex = NONE;</span><br><span class="line">            prevTakeIndex = DETACHED;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> takeIndex = ArrayBlockingQueue.<span class="keyword">this</span>.takeIndex;</span><br><span class="line">            prevTakeIndex = takeIndex;</span><br><span class="line">            nextItem = itemAt(nextIndex = takeIndex);</span><br><span class="line">            cursor = incCursor(takeIndex);</span><br><span class="line">            <span class="keyword">if</span> (itrs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                itrs = <span class="keyword">new</span> Itrs(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                itrs.register(<span class="keyword">this</span>); <span class="comment">// in this order</span></span><br><span class="line">                itrs.doSomeSweeping(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            prevCycles = itrs.cycles;</span><br><span class="line">            <span class="comment">// assert takeIndex &gt;= 0;</span></span><br><span class="line">            <span class="comment">// assert prevTakeIndex == takeIndex;</span></span><br><span class="line">            <span class="comment">// assert nextIndex &gt;= 0;</span></span><br><span class="line">            <span class="comment">// assert nextItem != null;</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h5><h6 id="Introduction-2"><a href="#Introduction-2" class="headerlink" title="Introduction"></a>Introduction</h6><p>&emsp;&emsp;基于链表的阻塞队列，同<code>ArrayListBlockingQueue</code>类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（<code>LinkedBlockingQueue</code>可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。  </p>
<p>&emsp;&emsp;<code>LinkedBlockingQueue</code>之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<br>&emsp;&emsp;作为开发者，我们需要注意的是，如果构造一个<code>LinkedBlockingQueue</code>对象，而没有指定其容量大小，<code>LinkedBlockingQueue</code>会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。  </p>
<p>&emsp;&emsp;<code>LinkedBlockingQueue</code>是一个使用链表完成队列操作的阻塞队列。链表是单向链表，而不是双向链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列的容量，指定大小或为默认值Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//元素的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//队列头节点，始终满足head.item==null</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//队列的尾节点，始终满足last.next==null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line">    <span class="comment">//出队的锁：take, poll, peek 等读操作的方法需要获取到这个锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line">    <span class="comment">//当队列为空时，保存执行出队的线程：如果读操作的时候队列是空的，那么等待 notEmpty 条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line">    <span class="comment">//入队的锁：put, offer 等写操作的方法需要获取到这个锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line">    <span class="comment">//当队列满时，保存执行入队的线程：如果写操作的时候队列是满的，那么等待 notFull 条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//传说中的无界队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//传说中的有界队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//传说中的无界队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表节点类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * One of:</span></span><br><span class="line"><span class="comment">         * - 真正的继任者节点</span></span><br><span class="line"><span class="comment">         * - 这个节点，意味着继任者是head.next</span></span><br><span class="line"><span class="comment">         * - 空，意味着没有后继者（这是最后一个节点）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(E x) &#123; item = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过其构造函数，得知其可以当做无界队列也可以当做有界队列来使用。</p>
<p>这里用了两把锁分别是<code>takeLock</code>与<code>putLock</code>、两个Condition分别是<code>notEmpty</code>与<code>notFull</code>，它们是这样搭配的：</p>
<ul>
<li>如果要获取（take）一个元素，需要获取 takeLock 锁，但是获取了锁还不够，如果队列此时为空，还需要队列不为空（notEmpty）这个条件（Condition）。  </li>
<li>如果要插入（put）一个元素，需要获取 putLock 锁，但是获取了锁还不够，如果队列此时已满，还需要队列不是满的（notFull）这个条件（Condition）。  </li>
</ul>
<p><strong>注意：</strong>从上面的构造函数中，这里会初始化一个空的头结点，那么第一个元素入队的时候，队列中就会有两个元素。读取元素时，也总是获取头节点后面的一个节点。count 的计数值不包括这个头节点。</p>
<h6 id="Put-1"><a href="#Put-1" class="headerlink" title="Put()"></a>Put()</h6><p>通过源码分析，透析<code>put()</code>方法的流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定元素插入到此队列的尾部，如有必要，则等待空间变得可用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 如果你纠结这里为什么是 -1，可以看看 offer 方法。这就是个标识成功、失败的标志而已。</span></span><br><span class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//包装成node节点</span></span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        <span class="comment">//获取锁定</span></span><br><span class="line">        putLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/** 如果队列满，等待 notFull 的条件满足。 */</span></span><br><span class="line">            <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//入队</span></span><br><span class="line">            enqueue(node);</span><br><span class="line">            <span class="comment">//原子性自增</span></span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            <span class="comment">// 如果这个元素入队后，还有至少一个槽可以使用，调用 notFull.signal() 唤醒等待线程。</span></span><br><span class="line">            <span class="comment">// 哪些线程会等待在 notFull 这个 Condition 上呢？</span></span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">            putLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 c == 0，那么代表队列在这个元素入队前是空的（不包括head空节点），</span></span><br><span class="line">        <span class="comment">// 那么所有的读线程都在等待 notEmpty 这个条件，等待唤醒，这里做一次唤醒操作</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            signalNotEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 链接节点在队列末尾 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">        <span class="comment">// assert last.next == null;</span></span><br><span class="line">        <span class="comment">// 入队的代码非常简单，就是将 last 属性指向这个新元素，并且让原队尾的 next 指向这个元素</span></span><br><span class="line">        <span class="comment">//last.next = node;</span></span><br><span class="line">        <span class="comment">//last = node;</span></span><br><span class="line">        <span class="comment">// 这里入队没有并发问题，因为只有获取到 putLock 独占锁以后，才可以进行此操作</span></span><br><span class="line">        last = last.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待PUT信号</span></span><br><span class="line"><span class="comment">     * 仅在 take/poll 中调用</span></span><br><span class="line"><span class="comment">     * 也就是说：元素入队后，如果需要，则会调用这个方法唤醒读线程来读</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">        putLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            notFull.signal();<span class="comment">//唤醒</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            putLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Take-1"><a href="#Take-1" class="headerlink" title="Take"></a>Take</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        E x;</span><br><span class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">        <span class="comment">//首先，需要获取到 takeLock 才能进行出队操作</span></span><br><span class="line">        takeLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果队列为空，等待 notEmpty 这个条件满足再继续执行</span></span><br><span class="line">            <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//// 出队</span></span><br><span class="line">            x = dequeue();</span><br><span class="line">            <span class="comment">//count 进行原子减 1</span></span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            <span class="comment">// 如果这次出队后，队列中至少还有一个元素，那么调用 notEmpty.signal() 唤醒其他的读线程</span></span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == capacity)</span><br><span class="line">            signalNotFull();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出队</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class="line">        <span class="comment">// assert head.item == null;</span></span><br><span class="line">        Node&lt;E&gt; h = head;</span><br><span class="line">        Node&lt;E&gt; first = h.next;</span><br><span class="line">        h.next = h; <span class="comment">// help GC</span></span><br><span class="line">        head = first;</span><br><span class="line">        E x = first.item;</span><br><span class="line">        first.item = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Signals a waiting put. Called only from take/poll.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">        putLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            notFull.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            putLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="与-ArrayBlockingQueue-对比"><a href="#与-ArrayBlockingQueue-对比" class="headerlink" title="与 ArrayBlockingQueue 对比"></a>与 ArrayBlockingQueue 对比</h6><ol>
<li><code>ArrayBlockingQueue</code>是共享锁，粒度大，入队与出队的时候只能有1个被执行，不允许并行执行。<code>LinkedBlockingQueue</code>是独占锁，入队与出队是可以并行进行的。当然这里说的是读和写进行并行，两者的读读与写写是不能并行的。总结就是<code>LinkedBlockingQueue</code>可以并发读写。    </li>
<li><code>ArrayBlockingQueue</code>和<code>LinkedBlockingQueue</code>间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。  </li>
</ol>
<h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h5><p>&emsp;&emsp;<code>DelayQueue</code>是一个无界阻塞队列，只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的<code>Delayed</code>元素。<br>&emsp;&emsp;存放到<code>DelayDeque</code>的元素必须继承<code>Delayed</code>接口。<code>Delayed</code>接口使对象成为延迟对象，它使存放在<code>DelayQueue</code>类中的对象具有了激活日期，该接口强制执行下列两个方法：  </p>
<ol>
<li>CompareTo(Delayed o)：Delayed接口继承了Comparable接口，因此有了这个方法  </li>
<li>getDelay(TimeUnit unit):这个方法返回到激活日期的剩余时间，时间单位由单位参数指定  </li>
</ol>
<p><strong>使用场景</strong></p>
<ol>
<li>关闭空闲连接。服务器中，有很多客户端的连接，空闲一段时间之后需要关闭之。  </li>
<li>缓存。缓存中的对象，超过了空闲时间，需要从缓存中移出。  </li>
<li>任务超时处理。在网络协议滑动窗口请求应答式交互时，处理超时未响应的请求。  </li>
</ol>
<h5 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h5><h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h5><p>&emsp;&emsp;它是一个特殊的队列，它的名字其实就蕴含了它的特征 – - 同步的队列。为什么说是同步的呢？这里说的并不是多线程的并发问题，而是因为当一个线程往队列中写入一个元素时，写入操作不会立即返回，需要等待另一个线程来将这个元素拿走；同理，当一个读线程做读操作的时候，同样需要一个相匹配的写线程的写操作。这里的 Synchronous 指的就是读线程和写线程需要同步，一个读线程匹配一个写线程，同理一个写线程匹配一个读线程。  </p>
<p>&emsp;&emsp;不像<code>ArrayBlockingQueue</code>、<code>LinkedBlockingDeque</code>之类的阻塞队列依赖AQS实现并发操作，<code>SynchronousQueue</code>直接使用CAS实现线程的安全访问。  </p>
<p>&emsp;&emsp;较少使用到 <code>SynchronousQueue</code> 这个类，不过它在线程池的实现类 <code>ScheduledThreadPoolExecutor</code> 中得到了应用。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//内部栈</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//内部队列</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">()</span> </span>&#123;<span class="keyword">this</span>(<span class="keyword">false</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        transferer = fair ? </span><br><span class="line">                 <span class="keyword">new</span> TransferQueue&lt;E&gt;() : <span class="keyword">new</span> TransferStack&lt;E&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以参考：<a href="https://blog.csdn.net/yanyan19880509/article/details/52562039" target="_blank" rel="noopener">java并发之SynchronousQueue实现原理</a></p>
</blockquote>

      
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="index-post card" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/21/concurrency/concurrency-1/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="龙门小左">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="程序猿的日常">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2018/06/21/concurrency/concurrency-1/" itemprop="url">JAVA并发编程与高并发解决方案 - 并发编程 一</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2018-06-21T10:00:00+08:00">2018-06-21 10:00:00</time></span>
        </span>
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="JAVA并发编程与高并发解决方案-并发编程-一"><a href="#JAVA并发编程与高并发解决方案-并发编程-一" class="headerlink" title="JAVA并发编程与高并发解决方案 - 并发编程 一"></a>JAVA并发编程与高并发解决方案 - 并发编程 一</h1><table>
<thead>
<tr>
<th style="text-align:center">版本</th>
<th style="text-align:center">作者</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2018.4.8</td>
<td style="text-align:center">chuIllusions</td>
<td style="text-align:center">首次发布</td>
</tr>
</tbody>
</table>
<h2 id="学习内容简介"><a href="#学习内容简介" class="headerlink" title="学习内容简介"></a>学习内容简介</h2><h3 id="并发编程知识点"><a href="#并发编程知识点" class="headerlink" title="并发编程知识点"></a>并发编程知识点</h3><p>线程安全、线程封闭、线程调度、同步容器、并发容器、AQS、J.U.C etc.</p>
<h3 id="高并发解决方案知识点"><a href="#高并发解决方案知识点" class="headerlink" title="高并发解决方案知识点"></a>高并发解决方案知识点</h3><p>扩容、缓存、队列、拆分、服务降级与熔断、数据库切库、分库分表 etc.</p>
<h3 id="面对人群"><a href="#面对人群" class="headerlink" title="面对人群"></a>面对人群</h3><p>从事JAVA开发的程序员</p>
<ol>
<li>对并发和高并发不了解的程序员</li>
<li>对并发和高并发了解的程序员</li>
<li>已经是编程高手的程序员</li>
</ol>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>构建完整的并发与高并发知识体系</p>
<ol>
<li>系统的学习到并发编程的知识及高并发处理思路</li>
<li>修正之前在不知不觉中犯过的一些并发方面的问题</li>
<li>规避以后开发中一些并发方面的问题</li>
<li>对你的知识进行一次更为全面的梳理，完善知识体系</li>
<li>学习到大量的实际场景案例分析和代码优化技巧</li>
<li>让你对并发编程和高并发处理有一个质的提升</li>
<li>将节省你准备面试的时间，让你的面试更有针对性</li>
<li>可以借鉴一些之前可能没有想到过的解决问题思路和手段</li>
</ol>
<h3 id="课程内容安排"><a href="#课程内容安排" class="headerlink" title="课程内容安排"></a>课程内容安排</h3><h4 id="基础知识讲解与核心知识准备"><a href="#基础知识讲解与核心知识准备" class="headerlink" title="基础知识讲解与核心知识准备"></a>基础知识讲解与核心知识准备</h4><p><img src="images/1.jpg" alt=""></p>
<h4 id="并发及并发的线程安全处理"><a href="#并发及并发的线程安全处理" class="headerlink" title="并发及并发的线程安全处理"></a>并发及并发的线程安全处理</h4><p><img src="images/2.jpg" alt=""></p>
<h4 id="高并发处理的思路及手段"><a href="#高并发处理的思路及手段" class="headerlink" title="高并发处理的思路及手段"></a>高并发处理的思路及手段</h4><p><img src="images/3.jpg" alt=""></p>
<h4 id="涉及知识技能"><a href="#涉及知识技能" class="headerlink" title="涉及知识技能"></a>涉及知识技能</h4><p>总体架构：Spring Boot、Maven、JDK8、MySQL</p>
<p>基础组件：Mybatis、Guava、Lombok、Redis、Kafka</p>
<p>高级组件(类)：Joda-Time、Atomic包、J.U.C、AQS、ThreadLocal、RateLimiter、Hystrix、ThreadPool、shardbatis、curator、elastic-job …</p>
<h3 id="场景举例-实现计数功能"><a href="#场景举例-实现计数功能" class="headerlink" title="场景举例 - 实现计数功能"></a>场景举例 - 实现计数功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5000个请求，每次只允许200个请求处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//线程池 + 信号量 进行请求的模拟</span></span><br><span class="line">        <span class="comment">//新建线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//定义信号量(后面会进行讲解)</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击运行结果，每一次结果都是不一样的，并且没有达到结果为5000，而是小于5000</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//每次允许threadTotal请求进行处理</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, map.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        map.put(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击运行结果，每一次结果都是不一样的，并且Map.size()没有达到结果为5000，而是小于5000</p>
<p>若上面两个例子中，<code>threadTotal = 1</code> 则会得到我们预期的结果，<code>size() = clientTotal = 5000</code></p>
<p>总结：当一个线程运行可以得到我们预期的结果，但当多个线程同时进行操作，就会出现并发问题，导致结果异常</p>
<h3 id="Slf4j"><a href="#Slf4j" class="headerlink" title="@Slf4j"></a>@Slf4j</h3><h4 id="slf4j"><a href="#slf4j" class="headerlink" title="slf4j"></a>slf4j</h4><p>对于一个maven项目。首先要在pom.xml中加入以下依赖项：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>slf4j就是众多接口的集合，它不负责具体的日志实现，只在编译时负责寻找合适的日志系统进行绑定。具体有哪些接口，全部都定义在slf4j-api中。</li>
<li>slf4j-log4j12是链接slf4j-api和log4j中间的适配器。它实现了slf4j-apiz中StaticLoggerBinder接口，从而使得在编译时绑定的是slf4j-log4j12的getSingleton()方法</li>
<li>log4j是具体的日志系统。通过slf4j-log4j12初始化Log4j，达到最终日志的输出。</li>
<li>lombok：一个插件，封装了log的get和set，可以直接使用log来输出日志信息。</li>
</ol>
<h4 id="slf4j-1"><a href="#slf4j-1" class="headerlink" title="@slf4j"></a>@slf4j</h4><p>如果不想每次都写<code>private  final Logger logger = LoggerFactory.getLogger(XXX.class);</code> 可以用注解<code>@Slf4j</code></p>
<p>引入依赖，使用方式如上场景举例中代码示例</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="解决IDEA使用-Slf4j注入后找不到变量log"><a href="#解决IDEA使用-Slf4j注入后找不到变量log" class="headerlink" title="解决IDEA使用@Slf4j注入后找不到变量log"></a>解决IDEA使用@Slf4j注入后找不到变量log</h4><p>方式一：</p>
<p>idea中File –&gt; settings –&gt; Plugins –&gt; 点击”Browse repositories” –&gt; 搜索lombok –&gt; Install Lombok Plugins</p>
<p>若插件安装失败，则可以进行以下安装方式</p>
<p>方式二：</p>
<p>去idea官网下载插件 <a href="http://plugins.jetbrains.com/plugin/6317-lombok-plugin" target="_blank" rel="noopener">Lombok Plugin</a> ，到下载区，选择合适的版本下载，我的idea版本为2017.1.4，因此选择插件的版本号为<code>0.16-2017.1.4</code> 下载到文件为<code>lombok-plugin-0.16.zip</code></p>
<p>注：idea任何插件的版本都需要跟idea版本对应，否则会提示安装失败(本人踩过的坑)</p>
<p>安装步骤：解压下载到的zip文件，拷贝解压文件到idea安装目录下的<code>plugins</code>文件下，打开idea中的 plugins &gt; 选择 install plugin from disk &gt; 选择刚刚拷贝进去的文件夹中的jar，即可进行安装，安装完成后需要进行重启。</p>
<h3 id="Lombox"><a href="#Lombox" class="headerlink" title="Lombox"></a>Lombox</h3><h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><p><a href="https://projectlombok.org/" target="_blank" rel="noopener">Lombok</a>项目是一个java库，可以自动插入到您的编辑器和构建工具中，让您的java变得更加精彩。切勿再次写入另一个getter或equals方法。提前访问未来的Java功能<code>val</code>，等等。</p>
<p>除了官方介绍中，并不多相关文章，特意挑了<a href="https://blog.csdn.net/l_blackeagle/article/details/62041873" target="_blank" rel="noopener">一篇文章中相关内容</a></p>
<blockquote>
<p>lombok 提供了简单的注解的形式来帮助我们简化消除一些必须有但显得很臃肿的 java 代码。特别是相对于 POJO。<br>简单来说，比如我们新建了一个类，然后在其中写了几个字段，然后通常情况下我们需要手动去建立getter和setter方法啊，构造函数啊之类的，lombok的作用就是为了省去我们手动创建这些代码的麻烦，它能够在我们编译源码的时候自动帮我们生成这些方法。</p>
<p>lombok能够达到的效果就是在源码中不需要写一些通用的方法，但是在编译生成的字节码文件中会帮我们生成这些方法，这就是lombok的神奇作用。</p>
<p>虽然有人可能会说IDE里面都自带自动生成这些方法的功能，但是使用lombok会使你的代码看起来更加简洁，写起来也更加方便。</p>
</blockquote>
<h4 id="常用的注解"><a href="#常用的注解" class="headerlink" title="常用的注解"></a>常用的注解</h4><p>@slf4j、@Setter、@Getter、@NoArgsConstructor(注解在类上：为类提供一个无参的构造方法)、@AllArgsConstructor(注解在类上；为类提供一个全参的构造方法)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span> <span class="comment">//注解在类上：为类提供一个无参的构造方法</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span><span class="comment">//注解在类上；为类提供一个全参的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//@Getter @Setter 注解在属性上；为属性提供 setting 方法 getting方法</span></span><br><span class="line">    <span class="meta">@Setter</span> <span class="meta">@Getter</span> <span class="keyword">private</span> <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="meta">@Setter</span> <span class="meta">@Getter</span> <span class="keyword">private</span> String pname;</span><br><span class="line">    <span class="meta">@Setter</span> <span class="meta">@Getter</span> <span class="keyword">private</span> <span class="keyword">int</span> sage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基础知识讲解与核心知识准备-1"><a href="#基础知识讲解与核心知识准备-1" class="headerlink" title="基础知识讲解与核心知识准备"></a>基础知识讲解与核心知识准备</h2><h3 id="并发与高并发基本概念"><a href="#并发与高并发基本概念" class="headerlink" title="并发与高并发基本概念"></a>并发与高并发基本概念</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>​    并发：同时拥有两个或者多个线程，如果程序在单核处理器运行，多个线程将交替地换入或者换出内存，这些线程是同时”存在”的，每个线程都处于执行过程中的某个状态，如果运行在多核处理器上，此时，程序中的每个线程都将会分配到一个处理器核上，因此可以同时运行</p>
<p>​    高并发：高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常指，通过设计保证系统能够同时并行处理很多请求</p>
<h4 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h4><p>​    并发：多个线程操作相同的资源，保证线程安全，合理使用资源</p>
<p>​    高并发：服务能同时处理很多请求，提高程序性能；如系统集中收到大量的请求（12306的抢票系统），导致系统在某段时间类执行大量的操作，包括对资源的请求、数据库的操作等等，如果高并发处理不好，不仅仅降低用户的体验度，请求时间变长，同时也可能导致系统宕机，甚至导致OOM（Out Of Memory）异常，如果想要系统适应高并发状态，就要有多个方面进行系统优化，包括硬件、网络、系统架构、开发语言的选取、数据结构的应用、算法的优化等等，这个时候谈论的是如何提供现有程序的性能，对高并发场景提供一些解决方案、手段等等</p>
<h3 id="CPU多级缓存"><a href="#CPU多级缓存" class="headerlink" title="CPU多级缓存"></a>CPU多级缓存</h3><p>​    在多线程并发环境下，如果不采取特殊手段，普通的累加结果很可能是错的。错的原因可能涉及到计算机原理以及JAVA方面的一些知识。</p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><img src="images/4.jpg" alt=""></p>
<p>Main Memory : 主存</p>
<p>Cache : 高速缓存，数据的读取和存储都经过此告诉缓存</p>
<p>CPU Core :  CPU核心</p>
<p>Bus :  系统总线</p>
<p>​    CUP Core 与 Cache 之间有一条快速通道，Main Memory 与 Cache 关联在 Bus 上，同时 Bus 还用于其他组件    的通信，在Cache出现不久后，系统变得更加复杂，Cache与Main Memory中速度的差异拉大，直到加入另一级的Cache，新加入的Cache 比 一级 Cache 更大，但是更慢，由于从加大一级Cache的做法，从经济上是行不通的，所以有了二级Cache，甚至已经有三级 Cache</p>
<h4 id="为什么需要CPU-CACHE"><a href="#为什么需要CPU-CACHE" class="headerlink" title="为什么需要CPU CACHE?"></a>为什么需要CPU CACHE?</h4><p>​    CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源，这样会使CPU花费很长时间等待数据到来或把数据写入内存。<strong>所以Cache的出现，是为了环境CPU和内存之间速度的不匹配问题（结构：CPU - &gt; CACHE - &gt; MEMORY）</strong></p>
<h4 id="CPU-CACHE-意义"><a href="#CPU-CACHE-意义" class="headerlink" title="CPU CACHE 意义"></a>CPU CACHE 意义</h4><p>​    缓存的容量远远小于主存，因此出现缓存不命中的情况在所难免，既然缓存不能包含CPU所需要的所有数据，那么Cache的存在真的有意义吗?</p>
<p>CPU缓存存在的意义分两点（局部性原理）：</p>
<ol>
<li>时间局部性：如果某个数据被访问，那么在不久的将来它很可能被再次访问</li>
<li>空间局限性：如果某个数据被访问，那么与它相邻的数据很快也可能被访问</li>
</ol>
<p>​       缓存的工作原理是当CPU要读取一个数据时，首先从缓存中查找，如果找到就立即读取并送给CPU处理；如果没有找到，就用相对慢的速度内存中读取并送给CPU处理，同时把这个数据所在的数据块调入缓存中，可以使得以后对整块数据的读取都从缓存中进行，不必再调用内存。</p>
<pre><code>正是这样的读取机制使CPU读取缓存的命中率非常高（大多数CPU可达90%左右），也就是说CPU下一次要读取的数据90%都在缓存中，大约10%需要从内存读取。
</code></pre><h4 id="缓存一致性（MESI）"><a href="#缓存一致性（MESI）" class="headerlink" title="缓存一致性（MESI）"></a>缓存一致性（MESI）</h4><p>​    缓存一致性用于保证多个CPU Cache之间缓存共享数据的一致性，定义了Cache Line四种状态，而CPU对Cache的四种操作，可能会产生不一致的状态，因此缓存控制器监听到本地操作和远程操作的时候 ，需要对Cache Line作出相应的修改，从而保证数据在多个缓存之间的一致性</p>
<p>​    Cache Line ： 是cache与内存数据交换的最小单位，根据操作系统一般是32byte或64byte。在MESI协议中，状态可以是M、E、S、I，地址则是cache line中映射的内存地址，数据则是从内存中读取的数据。</p>
<p>​    MESI其实是四种状态的缩写：M（modify）修改、E（exclusive）独占、S（shared）共享、I（invalid）失效。</p>
<p>​    状态间的相互转换关系：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">M</th>
<th style="text-align:center">E</th>
<th style="text-align:center">S</th>
<th style="text-align:center">I</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">I</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
<p>​    Cache 操作： MESI协议中，每个cache的控制器不仅知道自己的操作（local read和local write），通过监听也知道其他CPU中cache的操作（remote read和remote write）。对于自己本地缓存有的数据，CPU仅需要发起local操作，否则发起remote操作，从主存中读取数据，cache控制器通过总线监听，仅能够知道其他CPU发起的remote操作，但是如果local操作会导致数据不一致性，cache控制器会通知其他CPU的cache控制器修改状态。</p>
<blockquote>
<p>参考文章：<a href="https://blog.csdn.net/reliveit/article/details/50450136" target="_blank" rel="noopener">【并发编程】CPU cache结构和缓存一致性（MESI协议）</a></p>
</blockquote>
<h4 id="乱序执行优化"><a href="#乱序执行优化" class="headerlink" title="乱序执行优化"></a>乱序执行优化</h4><p>​    处理器为提高运算速度而做出违背代码原有顺序的优化</p>
<p>举个例子：</p>
<ol>
<li>计算 a <em> b ，a =10 ，b = 200 ，则 result = a </em> b = 2000</li>
<li>代码编写顺序：a=10 -&gt; b=200 -&gt; result = a * b</li>
<li><p>CPU乱序执行优化可能会发生执行顺序为：b=200 -&gt; a=10 -&gt; result = a * b</p>
<pre><code>CPU乱序执行优化不会对结果造成影响，在单核时代，处理器保证做出的优化，不会导致执行的结果远离预期的目标，但是在多核环境下并非如此。首先在多核环境中，同时会有多个核执行指令，每个核的指定都可能会被乱序优化，另外，处理器还引用了L1、L2等缓存机制，没个核都有自己的缓存，这就导致了逻辑次序上后写入内存的数据，未必真的最后写入，最终带来了这样的一个问题：如果我们不做任何防护措施，处理器最终得到的结果和我们逻辑得出的结果大不相同。比如我们在其中的一个核中执行数据写入操作，并在最后写一个标记，用来标记数据已经准备好了，然后从另外一个核上，通过那个标志，来判断数据是否已经就绪，这种做法它就存在一定的风险，标记位先被写入，但数据操作并未完成（可能是计算为完成、也可能是数据没有从缓存刷新到主存当中）， 最终导致另外的核使用了错误的数据。
</code></pre></li>
</ol>
<h3 id="Java-内存模型（Java-Memory-Model，JMM）"><a href="#Java-内存模型（Java-Memory-Model，JMM）" class="headerlink" title="Java 内存模型（Java Memory Model，JMM）"></a>Java 内存模型（Java Memory Model，JMM）</h3><p>​    CPU缓存一致性和乱序执行优化，在多核多并发下，需要额外做很多的事情，才能保证程序的执行，符合我们的预期。那么JVM（Java Virtual Machine (Java虚拟机)）是如何解决这些问题的?为了屏蔽掉各种硬件和操作系统的内存访问差异，实现让Java程序在各种平台下都能达到一致的并发效果，JMV规范中定义了JMM （Java Memory Model (Java 内存模型)）。 JMM是一种规范，它规范了JVM与计算机内存是如何协同工作的，它规定一个线程如何和何时可以看到其他线程修改过的共享变量的值，以及在必须时如何同步的访问共享变量。</p>
<h4 id="JVM内存分配概念"><a href="#JVM内存分配概念" class="headerlink" title="JVM内存分配概念"></a>JVM内存分配概念</h4><p><img src="images/5.jpg" alt=""></p>
<center>图 JVM内存分配概念</center>

<p>JVM内存分配的两个概念：Stack（栈）和Heap（堆）。</p>
<p>​    Java中的Heap是运行时数据区，由垃圾回收负责，它的优势是动态的分配内存大小，生存期也不必事先告诉编    译器，在运行时动态分配内存，Java的垃圾收集器，会自动回收不再使用的数据。但是也有缺点，由于是要在运行时动态分配内存，因此存取速度相对较慢。</p>
<p>​    Java中的Stack优势是存取速度比Heap要快，仅次于计算机中的寄存器，栈中的数据是可以共享的，但是它的缺点是，存在栈中数据的大小和生存期必须是确定的，缺乏灵活性，主要存放一些基本类型的变量。</p>
<p>​    JMM要求调用栈和本地变量存放在线程栈中，对象存放在堆上。一个本地变量可能指向一个对象的引用，引用这个本地变量是存放在线程栈上，而对象本身是存放在堆上的。一个对象可能包含方法，这些方法可能包含本地变量，这些本地变量还是存放在线程栈中，即使这些方法所属的对象存放在堆上。一个对象的成员变量可能会随着这个对象自身存放在堆上，不管这个成员对象是原始类型还是引用类型，静态成员变量跟随着类的定义一起存放在堆上。存放在堆上的对象，可以被所持有对这个对象引用线程的访问。</p>
<p>​    当一个线程可以访问一个对象的时候，它也可以访问该对象的成员变量，如果两个线程同时调用同一个对象的同一个方法，将会都访问该对象的成员变量，但是每一个线程都拥有了这个成员变量的私有拷贝。</p>
<h4 id="计算机内存硬件架构"><a href="#计算机内存硬件架构" class="headerlink" title="计算机内存硬件架构"></a>计算机内存硬件架构</h4><p><img src="images/6.jpg" alt=""></p>
<center>计算机硬件架构简单图示</center>

<p>​    CPU，一台现代计算机拥有两个或多个CPU，其中一些CPU还有多核，从这一点可以看出，在一个有两个或多个CPU的现代计算机上，同时运行多个线程是非常有可能的，而且每个CPU在某一个时刻，运行一个线程是肯定没有问题的，这意味着，如果Java程序是多线程的，在Java程序中，每个CPU上一个线程是可能同时并发执行的。</p>
<p>​    CPU Refisters（寄存器），每个CPU都包含一系列的寄存器，它们是CPU内存的基础，CPU在寄存器中执行操作的速度远大于在主存上执行的速度，这是因为CPU访问寄存器的速度远大于主存。</p>
<p>​    Cache（高速缓存），由于计算机的存储设备与处理器运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高级缓存来作为内存与处理器之间的缓冲，将运算需要使用到的数据复制到缓存中，让运算能快速的进行，当运算结束后，在从缓存同步到内存中。这样处理器就无需等待缓慢的内存读写，CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度要慢。</p>
<p>​    Main Memory（主存），随机存取存储器（random access memory，RAM）又称作“随机存储器”，一个计算机包含一个主存，所有的CPU都可以访问主存，主存通常比CPU中的缓存大得多。</p>
<h4 id="JVM-与-Computer"><a href="#JVM-与-Computer" class="headerlink" title="JVM 与 Computer"></a>JVM 与 Computer</h4><p><img src="images/7.jpg" alt=""></p>
<p>​    JVM 与 Computer 内存架构存在差异，硬件内存并无区分栈与堆，对于硬件而言，所有的栈和堆都分布在主内存中，可能会出现在高速缓存、寄存器中。     </p>
<h4 id="内存模型抽象结构"><a href="#内存模型抽象结构" class="headerlink" title="内存模型抽象结构"></a>内存模型抽象结构</h4><p><img src="images/8.jpg" alt=""></p>
<h4 id="Java内存模型-同步八种操作"><a href="#Java内存模型-同步八种操作" class="headerlink" title="Java内存模型 - 同步八种操作"></a>Java内存模型 - 同步八种操作</h4><ol>
<li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态</li>
<li>unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li>
<li>read（读取）：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值存放工作内存的变量副本中</li>
<li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量</li>
<li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传递到主内存中，以便随后的write的操作</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中</li>
</ol>
<h4 id="Java内存模型-同步规则"><a href="#Java内存模型-同步规则" class="headerlink" title="Java内存模型 - 同步规则"></a>Java内存模型 - 同步规则</h4><ol>
<li>如果要把一个变量从主内存中复制到工作内存，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作，但Java内存模型只要求上述操作必须按顺序执行，而没有保证是连续执行</li>
<li>不允许read和load、store和write操作之一单独出现</li>
<li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作</li>
<li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次与执行lock后，只有执行相同次数的unlock，变量才会被解锁。lock和unlock必须成对出现</li>
<li>如果一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li>
<li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量</li>
<li>对一个变量执行unlock操作之前，必须先把变量同步到主内存中（执行store和write操作）</li>
</ol>
<h4 id="Java-内存模型-同步操作与规则"><a href="#Java-内存模型-同步操作与规则" class="headerlink" title="Java 内存模型 - 同步操作与规则"></a>Java 内存模型 - 同步操作与规则</h4><p><img src="images/9.jpg" alt=""></p>
<h3 id="并发的优势与风险"><a href="#并发的优势与风险" class="headerlink" title="并发的优势与风险"></a>并发的优势与风险</h3><p><img src="images/10.jpg" alt=""></p>
<h2 id="并发编程与线程安全"><a href="#并发编程与线程安全" class="headerlink" title="并发编程与线程安全"></a>并发编程与线程安全</h2><p>​    代码所在的进程，有多个线程同时运行，而这些线程可能会同时运行同一段代码，如果每次运行结果和单线程预期结果一致，变量值也和预期一致，则认为这是线程安全的。简单的说，就是并发环境下，得到我们期望正确的结果。对应的一个概念就是线程不安全，就是不提供数据访问保护，有可能出现多个线程，先后更改数据，造成所得到的数据是脏数据，也可能是计算错误。</p>
<h3 id="环境搭建准备"><a href="#环境搭建准备" class="headerlink" title="环境搭建准备"></a>环境搭建准备</h3><h4 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h4><p>Spring Boot 项目，<a href="https://start.spring.io" target="_blank" rel="noopener">https://start.spring.io</a></p>
<h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>​    为方便理解，自定义一些注解，方便理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 课程里用来标记【线程安全】的类或者写法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE) <span class="comment">//作用域，作用于类上</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE) <span class="comment">//注解存在的范围，编译时忽略</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ThreadSafe &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给默认值，方便扩展</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 课程里用来标记【线程不安全】的类或者写法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NotThreadSafe &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 课程里用来标记【推荐】的类或者写法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Recommend &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 课程里用来标记【不推荐】的类或者写法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NotRecommend &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并发模拟"><a href="#并发模拟" class="headerlink" title="并发模拟"></a>并发模拟</h3><h4 id="模拟准备工具介绍"><a href="#模拟准备工具介绍" class="headerlink" title="模拟准备工具介绍"></a>模拟准备工具介绍</h4><ol>
<li>Postman：Http请求模拟工具</li>
<li>Apache Bench（AB）：Apache附带的工具，测试网站性能</li>
<li>JMeter：Apache组织开发的压力测试工具</li>
<li>代码模拟：Semaphore、CountDownLatch等</li>
</ol>
<p>服务准备</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h4><p>​    Postman本身是一个Http模拟工具，在并发上并不是专业的</p>
<p>使用步骤：</p>
<ol>
<li>打开Postman访问<code>localhost:8080/test</code>，完成一次服务访问</li>
<li>找到Collections标签，新建concurrency文件夹，将刚访问的连接Save文件夹中，并点击文件夹进入测试准备</li>
<li>配置参数，点击Run Concurrency，成功后查看结果</li>
</ol>
<p><img src="images/postman-1.png" alt=""></p>
<p><img src="images/postman-2.png" alt=""></p>
<p><img src="images/postman-3.png" alt=""></p>
<h4 id="Apache-Bench-AB"><a href="#Apache-Bench-AB" class="headerlink" title="Apache Bench(AB)"></a>Apache Bench(AB)</h4><p>​    Apache Bench 是 Apache 服务器自带的一个web压力测试工具，简称ab。ab又是一个命令行工具，对发起负载的本机要求很低，根据ab命令可以创建很多的并发访问线程，模拟多个访问者同时对某一URL地址进行访问，因此可以用来测试目标服务器的负载压力。总的来说ab工具小巧简单，上手学习较快，可以提供需要的基本性能指标，但是没有图形化结果，不能监控。</p>
<h5 id="Windows-7-安装"><a href="#Windows-7-安装" class="headerlink" title="Windows 7 安装"></a>Windows 7 安装</h5><ol>
<li>首先需要安装Apache服务器，<a href="https://www.apachelounge.com/download/" target="_blank" rel="noopener">点击下载</a></li>
<li>将下载<code>httpd-2.4.33-win64-VC15.zip</code>解压</li>
<li>配置环境变量，这里为了方便，我没有配置，直接进入bin目录，运行控制台</li>
<li>输入ab命名，若出现以下提示则环境准备成功</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">D:\apache\Apache24\bin&gt;ab</span><br><span class="line">ab: wrong number of arguments</span><br><span class="line">Usage: ab [options] [http://]hostname[:port]/path</span><br><span class="line">Options are:</span><br><span class="line">    -n requests     Number of requests to perform</span><br><span class="line">    -c concurrency  Number of multiple requests to make at a time</span><br><span class="line">    -t timelimit    Seconds to max. to spend on benchmarking</span><br><span class="line">                    This implies -n 50000</span><br><span class="line">    -s timeout      Seconds to max. <span class="built_in">wait</span> <span class="keyword">for</span> each response</span><br><span class="line">                    Default is 30 seconds</span><br><span class="line">    -b windowsize   Size of TCP send/receive buffer, <span class="keyword">in</span> bytes</span><br><span class="line">    -B address      Address to <span class="built_in">bind</span> to when making outgoing connections</span><br><span class="line">    -p postfile     File containing data to POST. Remember also to <span class="built_in">set</span> -T</span><br><span class="line">    -u putfile      File containing data to PUT. Remember also to <span class="built_in">set</span> -T</span><br><span class="line">    -T content-type Content-type header to use <span class="keyword">for</span> POST/PUT data, eg.</span><br><span class="line">                    <span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">                    Default is <span class="string">'text/plain'</span></span><br><span class="line">    -v verbosity    How much troubleshooting info to <span class="built_in">print</span></span><br><span class="line">    -w              Print out results <span class="keyword">in</span> HTML tables</span><br><span class="line">    -i              Use HEAD instead of GET</span><br><span class="line">    -x attributes   String to insert as table attributes</span><br><span class="line">    -y attributes   String to insert as tr attributes</span><br><span class="line">    -z attributes   String to insert as td or th attributes</span><br><span class="line">    -C attribute    Add cookie, eg. <span class="string">'Apache=1234'</span>. (repeatable)</span><br><span class="line">    -H attribute    Add Arbitrary header line, eg. <span class="string">'Accept-Encoding: gzip'</span></span><br><span class="line">                    Inserted after all normal header lines. (repeatable)</span><br><span class="line">    -A attribute    Add Basic WWW Authentication, the attributes</span><br><span class="line">                    are a colon separated username and password.</span><br><span class="line">    -P attribute    Add Basic Proxy Authentication, the attributes</span><br><span class="line">                    are a colon separated username and password.</span><br><span class="line">    -X proxy:port   Proxyserver and port number to use</span><br><span class="line">    -V              Print version number and <span class="built_in">exit</span></span><br><span class="line">    -k              Use HTTP KeepAlive feature</span><br><span class="line">    -d              Do not show percentiles served table.</span><br><span class="line">    -S              Do not show confidence estimators and warnings.</span><br><span class="line">    -q              Do not show progress when doing more than 150 requests</span><br><span class="line">    -l              Accept variable document length (use this <span class="keyword">for</span> dynamic pages)</span><br><span class="line">    -g filename     Output collected data to gnuplot format file.</span><br><span class="line">    -e filename     Output CSV file with percentages served</span><br><span class="line">    -r              Don<span class="string">'t exit on socket receive errors.</span></span><br><span class="line"><span class="string">    -m method       Method name</span></span><br><span class="line"><span class="string">    -h              Display usage information (this message)</span></span><br></pre></td></tr></table></figure>
<p>提示：若启动ab.exe时候，提示缺少某种依赖库，则需要安装该依赖库才可进行启动</p>
<h5 id="运行演示"><a href="#运行演示" class="headerlink" title="运行演示"></a>运行演示</h5><p>运行命令：<code>ab -n 1000 -c 50 http://localhost:8080/test</code></p>
<p>命令解析：-n 请求总次数 -c 并发数 URL地址</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">D:\apache\Apache24\bin&gt;ab -n 1000 -c 50 http://localhost:8080/test</span><br><span class="line">This is ApacheBench, Version 2.3 &lt;$Revision: 1826891 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><br><span class="line">Licensed to The Apache Software Foundation, http://www.apache.org/</span><br><span class="line"></span><br><span class="line">Benchmarking localhost (be patient)</span><br><span class="line">Completed 100 requests</span><br><span class="line">Completed 200 requests</span><br><span class="line">Completed 300 requests</span><br><span class="line">Completed 400 requests</span><br><span class="line">Completed 500 requests</span><br><span class="line">Completed 600 requests</span><br><span class="line">Completed 700 requests</span><br><span class="line">Completed 800 requests</span><br><span class="line">Completed 900 requests</span><br><span class="line">Completed 1000 requests</span><br><span class="line">Finished 1000 requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server Software:</span><br><span class="line">Server Hostname:        localhost</span><br><span class="line">Server Port:            8080</span><br><span class="line"></span><br><span class="line">Document Path:          /test</span><br><span class="line">Document Length:        4 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      50                 # 并发量</span><br><span class="line">Time taken for tests:   0.834 seconds      # 整个测试使用的时间</span><br><span class="line">Complete requests:      1000               # 完成请求数</span><br><span class="line">Failed requests:        0                  # 失败请求数</span><br><span class="line">Total transferred:      136000 bytes       # 所有请求响应数据的总和（包括Http 头信息和正文数据长度，服务器流向应用层数据总长度）</span><br><span class="line">HTML transferred:       4000 bytes   # 所有响应数据，正文数据总和</span><br><span class="line">Requests per second:    1198.97 [#/sec] (mean) # 吞吐率，与并发数相关</span><br><span class="line">Time per request:       41.702 [ms] (mean) # 用户平均请求等待时间</span><br><span class="line">Time per request:       0.834 [ms] (mean, across all concurrent requests) # 服务器平均请求等待时间</span><br><span class="line">Transfer rate:          159.24 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    0   0.8      0      24</span><br><span class="line">Processing:     1   39  87.7     14     584</span><br><span class="line">Waiting:        0   31  75.8     11     558</span><br><span class="line">Total:          2   39  87.7     14     584</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line"><span class="meta">  50%</span><span class="bash">     14</span></span><br><span class="line"><span class="meta">  66%</span><span class="bash">     20</span></span><br><span class="line"><span class="meta">  75%</span><span class="bash">     27</span></span><br><span class="line"><span class="meta">  80%</span><span class="bash">     31</span></span><br><span class="line"><span class="meta">  90%</span><span class="bash">     50</span></span><br><span class="line"><span class="meta">  95%</span><span class="bash">    220</span></span><br><span class="line"><span class="meta">  98%</span><span class="bash">    395</span></span><br><span class="line"><span class="meta">  99%</span><span class="bash">    464</span></span><br><span class="line"><span class="meta"> 100%</span><span class="bash">    584 (longest request)</span></span><br></pre></td></tr></table></figure>
<h4 id="JMeter"><a href="#JMeter" class="headerlink" title="JMeter"></a>JMeter</h4><p>​    相对于AB来说，JMeter更加强大。Apache JMeter是Apache组织开发的基于Java的压力测试工具。JMeter 可以用于对服务器、网络或对象模拟巨大的负载，来自不同压力类别下测试它们的强度和分析整体性能。</p>
<blockquote>
<p>参考文章：<a href="https://www.cnblogs.com/ceshisanren/p/5639895.html" target="_blank" rel="noopener">JMeter使用入门</a></p>
</blockquote>
<h5 id="Windows-7-安装-1"><a href="#Windows-7-安装-1" class="headerlink" title="Windows 7 安装"></a>Windows 7 安装</h5><ol>
<li>进入官网<a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">下载</a></li>
<li>将下载后的<code>apache-jmeter-4.0.zip</code>解压</li>
<li>进入解压目录中的bin目录，运行<code>jmeter.bat</code></li>
</ol>
<h5 id="运行演示-1"><a href="#运行演示-1" class="headerlink" title="运行演示"></a>运行演示</h5><h6 id="创建线程组"><a href="#创建线程组" class="headerlink" title="创建线程组"></a>创建线程组</h6><p><img src="images/jmeter-1.png" alt=""></p>
<p><img src="images/jmeter-2.png" alt=""></p>
<p>Number of Threads(users) : 线程数、虚拟用户数</p>
<p>Ramp-Up Period(in second) : 虚拟用户增长时长。理解：假设现在有一个考勤系统 ，所有的用户都不是同时登陆的，实际使用场景是在某段时间内，用户会陆陆续续的进行考勤，而这个参数大概理解就是这个意思，考勤是从8点40分到9点10分，那么这个参数就是30分钟*60秒，意味着指定用户请求在规定时间内完成请求。</p>
<p>Loop Count : 循环次数，每个虚拟用户循环的次数，如果勾选Forever则会一直进行下去，默认是1</p>
<h6 id="添加请求"><a href="#添加请求" class="headerlink" title="添加请求"></a>添加请求</h6><p><img src="images/jmeter-3.png" alt=""></p>
<p><img src="images/jmeter-4.png" alt=""></p>
<p>为请求添加结果监听：图形结果（Graph Results）与查看结果树（View Results Tree）</p>
<p><img src="images/jmeter-5.png" alt=""></p>
<h6 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h6><p><img src="images/jmeter-6.png" alt=""></p>
<p><img src="images/jmeter-7.png" alt=""></p>
<h4 id="代码模拟"><a href="#代码模拟" class="headerlink" title="代码模拟"></a>代码模拟</h4><h5 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h5><p>​    CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。</p>
<p><img src="images/countdownlatch-1.png" alt=""></p>
<p>假设计数器的值为3，线程A调用await()方法之后，当前线程就进入了等待状态， 之后在其他线程中执行countDown()，计数器就会 - 1 ，该操作线程继续执行，当计数器从3变成0之后，线程A继续执行。</p>
<p>CountDownLatch这个类可以阻塞线程，保证线程在某种特定的条件下，继续执行。</p>
<h5 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h5><p><img src="images/semaphore-1.png" alt=""></p>
<p>​    Semaphore翻译成字面意思为 信号量，Semaphore可以阻塞进程并且控制同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。</p>
<p>​    CountDownLatch与Semaphore在使用时，通常会与线程池配合使用</p>
<p>​    Semaphore适合控制并发数，CountDownLatch比较适合保证线程执行完后再执行其他处理，因此模拟并发时，使用两者结合起来是最好的。</p>
<h5 id="并发模拟代码实现"><a href="#并发模拟代码实现" class="headerlink" title="并发模拟代码实现"></a>并发模拟代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span> <span class="comment">//线程不安全的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//定义信号量</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="comment">//定义计数器闭锁</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire(); <span class="comment">//获取信号量，否则会阻塞</span></span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown(); <span class="comment">//每执行一次则减1</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown(); <span class="comment">//关闭线程池</span></span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//线程不安全</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="index-post card" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/21/concurrency/concurrency-4/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="龙门小左">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="程序猿的日常">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2018/06/21/concurrency/concurrency-4/" itemprop="url">JAVA并发编程与高并发解决方案 - 并发编程 四</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2018-06-21T10:00:00+08:00">2018-06-21 10:00:00</time></span>
        </span>
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="JAVA并发编程与高并发解决方案-并发编程-四"><a href="#JAVA并发编程与高并发解决方案-并发编程-四" class="headerlink" title="JAVA并发编程与高并发解决方案 - 并发编程 四"></a>JAVA并发编程与高并发解决方案 - 并发编程 四</h1><table>
<thead>
<tr>
<th style="text-align:center">版本</th>
<th style="text-align:center">作者</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2018.4.8</td>
<td style="text-align:center">chuIllusions</td>
<td style="text-align:center">J.U.C之AQS</td>
</tr>
</tbody>
</table>
<h3 id="J-U-C-之-AQS"><a href="#J-U-C-之-AQS" class="headerlink" title="J.U.C 之 AQS"></a>J.U.C 之 AQS</h3><h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><p>&emsp;&emsp;AbStractQueuedSynchronizer类，简称AQS，一个用来构建锁和同步器的框架 。从JDK1.5开始，引入了并发包，也就是J.U.C，大大提高了JAVA程序的并发性能，而AQS则是J.U.C的核心，是并发类中核心部分，它提供一个基于FIFO队列，这个队列可以构建锁或其他相关的同步装置的基础框架。  </p>
<p>&emsp;&emsp;AQS底层数据结构：</p>
<p><img src="images/aqs-1.png" alt=""></p>
<p>底层采用双向链表，是队列的一种实现，因此可以当做是一个队列。其中<code>Sync queue</code>即同步队列，它是双向链表，包括<code>hean</code>结点（主要用作后续的调度）与<code>tail</code>结点。<code>Condition queue</code>不是必须的，单向链表，只有在需要使用到<code>condition</code>的时候才会存在这个单向链表，并且可能存在多个<code>Condition queue</code></p>
<h4 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h4><ul>
<li>使用Node实现FIFO队列，可以用于构建锁或者其他同步装置的基础框架  </li>
<li>利用了一个int类型表示状态。在AQS中，存在一个<code>state</code>成员变量，基于AQS有一个同步组件<code>ReentrantLock</code>，在这个组件中，<code>state</code>表示获取锁的线程数，假如<code>state == 0</code>表示无线程获取锁，<code>state == 1</code>表示已有线程获取锁，<code>state &gt; 1</code>表示锁的数量  </li>
<li>使用方法是继承。AQS的设计是基于模板方法，使用需要继承AQS，并覆写其中的方法。  </li>
<li>子类通过继承并通过实现它的方法管理其状态{acquire() 和 release()}的方法操纵状态  </li>
<li>可以同时实现排它锁和共享锁模式（独占、共享）。它的所有子类中，要么实现并使用它的独占功能API，要么实现共享锁的功能，而不会同时使用两套API。即便是它比较有名的子类<code>ReentrantReadWirteLock</code>也是通过两个内部类读锁和写锁分别使用两套API实现的。AQS在功能上，有独占控制和共享控制两种功能。  </li>
<li>在LOCK包中的相关锁(常用的有ReentrantLock、 ReadWriteLock)都是基于AQS来构建.然而这些锁都没有直接来继承AQS,而是定义了一个Sync类去继承AQS，因为锁面向的是使用用户,而同步器面向的则是线程控制,那么在锁的实现中聚合同步器而不是直接继承AQS就可以很好的隔离二者所关注的事情.  </li>
</ul>
<p>基于以上设计，AQS具体实现的大致思路：</p>
<p>&emsp;&emsp;AQS内部维护了一个CLH队列来管理锁，线程首先会尝试获取锁，如果失败，会将当前线程以及等待状态等信息包装成Node结点加入同步队列（Sync queue）中。接着不断循环尝试获取锁，条件是当前结点为head直接后继才会尝试，如果失败则会阻塞自己，直到自己被唤醒；而当持有锁的线程，释放锁的时候，会唤醒队列中后继线程。基于这些基础的设计和思路，JDK提供了许多基于AQS的子类。  </p>
<p>独占式锁过程总结：  </p>
<p>&emsp;&emsp;AQS的模板方法acquire通过调用子类自定义实现的tryAcquire获取同步状态失败后-&gt;将线程构造成Node节点(创建一个独占式节点 )(addWaiter)-&gt;将Node节点添加到同步队列对尾(addWaiter)-&gt;节点以自旋的方法获取同步状态(acquirQueued)。在节点自旋获取同步状态时，只有其前驱节点是头节点的时候才会尝试获取同步状态，如果该节点的前驱不是头节点或者该节点的前驱节点是头节点单获取同步状态失败，则判断当前线程需要阻塞，如果需要阻塞则需要被唤醒过后才返回。在释放同步状态时，同步器调用tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后继节点。   </p>
<p>共享式锁过程总结：  </p>
<p>&emsp;&emsp;共享式获取与独占式获取的最主要区别在于同一时刻能否有多个线程同时获取到同步状态。通过调用acquireShared(int arg)方法可以共享式得获取同步状态。   </p>
<p>&emsp;&emsp;同步器调用<code>tryAcquireShared(int arg)</code>方法尝试获取同步状态，其返回值为int类型，当返回值大于0时，表示能够获取同步状态。因此，在共享式获取的自旋过程中，成功获取同步状态并且退出自旋的条件就是<code>tryAcquireShared(int arg)</code>方法返回值大于等于0。共享式释放同步状态状态是通过调用<code>releaseShared(int arg)</code>方法   </p>
<p>&emsp;&emsp;<code>CountDownLatch</code>、<code>ReentrantReadWriteLock</code>、<code>Semaphore</code>等都是共享式获取同步状态的。   </p>
<h4 id="同步队列结构分析"><a href="#同步队列结构分析" class="headerlink" title="同步队列结构分析"></a>同步队列结构分析</h4><p>&emsp;&emsp;本小节内容引用于<a href="https://blog.csdn.net/fjse51/article/details/54694714" target="_blank" rel="noopener">AQS实现分析</a> </p>
<p><img src="images/syn-queue-1.png" alt=""></p>
<p>&emsp;&emsp;同步器中包含了两个节点类型的引用，一个指向头节点(head)，一个指向尾节点(tail),没有获取到锁的线程，加入到队列的过程必须保证线程安全，因此同步器提供了一个基于CAS的设置尾节点的方法<code>CompareAndSetTail(Node expect,Node update)</code>,它需要传递当前线程认为的尾节点和当前节点，只有设置成功后，当前节点才能正式与之前的尾节点建立关联。  </p>
<p>&emsp;&emsp;同步器将结点加入到同步队列的过程：  </p>
<p><img src="images/syn-queue-2.png" alt=""></p>
<p>&emsp;&emsp;同步队列遵循FIFO，首节点是获取锁成功的节点，首节点的线程在释放锁时，将会唤醒后继节点，而后继节点将会在获取到锁时，将自己设置位首节点，设置首节点是由成功获取锁的线程来完成的，由于只有一个线程能够成功获取锁，因此设置首节点不需要CAS操作。 过程如下所示：  </p>
<p><img src="images/syn-queue-3.png" alt=""></p>
<h4 id="同步组件概览"><a href="#同步组件概览" class="headerlink" title="同步组件概览"></a>同步组件概览</h4><ul>
<li>CountDownLatch：是闭锁，通过一个计数来保证线程是否需要一直阻塞</li>
<li>Semaphore：控制同一时间，并发线程的数目</li>
<li>CyclicBarrier：和<code>CountDwonLatch</code>相似，能阻塞线程</li>
<li>ReentrantLock</li>
<li>Condition：使用时需要<code>ReentrantLock</code></li>
<li>FutureTask</li>
</ul>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>&emsp;&emsp;<code>CountDownLatch</code>是一个同步辅助类，已在第一篇文章中提到。内容通过截图显示：  </p>
<p><img src="images/countdownlatch-2.png" alt=""></p>
<p>&emsp;&emsp;构造器中的计数值（count）实际上就是闭锁需要等待的线程数量。这个值只能被设置一次，而且<code>CountDownLatch</code>没有提供任何机制去重新设置这个计数值。   </p>
<p>&emsp;&emsp;典型的应用：并行计算，当某个任务需要处理运算量非常大，可以将该运算任务拆分为多个子任务，等待所有的子任务完成之后，父任务再拿到所有子任务的运算结果进行汇总。利用<code>CountDownLatch</code>可以保证任务都被处理完才去执行最终的结果运算，过程中每一个线程都可以看做是一个子任务。  </p>
<p>&emsp;&emsp;案例：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	 	<span class="comment">//定义线程池</span></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">		<span class="comment">//定义闭锁实例</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            <span class="comment">//每次放入一个线程</span></span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    test(threadNum);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//计算器完成一次</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        <span class="comment">//所有子任务执行完后才会执行</span></span><br><span class="line">        log.info(<span class="string">"finish"</span>);</span><br><span class="line">        <span class="comment">//线程池不再使用需要关闭</span></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, threadNum);</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CountDownLatch</code>还提供在指定时间内完成的条件（超出时间没有完成，完成多少算多少），如果等待时间没有完成，则继续执行。通过<code>countDownLatch.await(int timeout,TimeUnit timeUnit);</code>设置，第一个参数没超时时间，第二个参数为时间单位  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    test(threadNum);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await(<span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="comment">//线程未完成，就可以输出以下信息</span></span><br><span class="line">        log.info(<span class="string">"finish"</span>);</span><br><span class="line">        <span class="comment">//执行关闭线程池，内部先把所有正在工作的线程完成后，再关闭</span></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//等待时间</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, threadNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><h5 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h5><p>&emsp;&emsp;<code>Semaphore</code>经常用于限制获取某种资源的线程数量，其内部是基于AQS的共享模式，AQS的状态表示许可证的数量，在许可证数量不够时，线程将会被挂起；而一旦有一个线程释放一个资源，那么就有可能重新唤醒等待队列中的线程继续执行。 已在第一篇文章中提到。内容通过截图显示：  </p>
<p><img src="images/semaphore-2.png" alt=""></p>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>&emsp;&emsp;Semaphore可以用于做流量控制，特别公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发的读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有十个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，我们就可以使用Semaphore来做流控   </p>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample1</span> </span>&#123;</span><br><span class="line">	<span class="comment">//总共有20个线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">		<span class="comment">//定义信号量，并且制定每次可用的许可数量</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire(); <span class="comment">// 获取一个许可</span></span><br><span class="line">                    test(threadNum);</span><br><span class="line">                    semaphore.release(); <span class="comment">// 释放一个许可</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, threadNum);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从上面的输出结果，每次输出一组日志，每一组日志有三条记录，直到所有线程执行完毕。使用<code>Semaphore</code>进行并发的控制，使用相当容易，但是效果很明显。同时也支持获取多个许可，以下例子即是一次只允许一个线程执行：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire(<span class="number">3</span>); <span class="comment">// 获取多个许可</span></span><br><span class="line">                    test(threadNum);</span><br><span class="line">                    <span class="comment">//也可以分别释放许可</span></span><br><span class="line">                    semaphore.release(<span class="number">3</span>); <span class="comment">// 释放多个许可</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, threadNum);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h5><p>&emsp;&emsp;尝试获取许可，如果获取不成功，则放弃操作，<code>tryAcquire</code>方法提供几个重载  </p>
<ol>
<li><code>tryAcquire() : boolean</code></li>
<li><code>tryAcquire(int permits) : boolean</code>  尝试获取指定数量的许可</li>
<li><code>tryAcquire(int permits,long timeout,TimeUnit timeUnit) : boolean</code></li>
<li><code>tryAcquire(long timeout,TimeUnit timeUnit) : boolean</code> 尝试获取许可的时候可以等待一段时间，在指定时间内未获取到许可则放弃</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//如果获取失败，则不进行操作</span></span><br><span class="line">                    <span class="comment">//semaphore.tryAcquire(5000,TimeUnit.MILLISECONDS)</span></span><br><span class="line">                    <span class="keyword">if</span> (semaphore.tryAcquire()) &#123; <span class="comment">// 尝试获取一个许可</span></span><br><span class="line">                        test(threadNum);</span><br><span class="line">                        semaphore.release(); <span class="comment">// 释放一个许可</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, threadNum);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>&emsp;&emsp;<code>Semaphore</code>有两种模式，公平模式和非公平模式。公平模式就是调用<code>acquire</code>的顺序就是获取许可证的顺序，遵循<code>FIFO</code>；而非公平模式是抢占式的，也就是有可能一个新的获取线程恰好在一个许可证释放时得到了这个许可证，而前面还有等待的线程。   </p>
<p>&emsp;&emsp;<code>Semaphore</code>构造函数  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 只指定许可量，构造不公平模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 指定许可量，并指定模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Semaphore内部基于AQS的共享模式，所以实现都委托给了Sync类。 </span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * NonFair version</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">        NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            <span class="comment">// 可以看到调用了setState方法，也就是说AQS中的资源就是许可证的数量。</span></span><br><span class="line">            <span class="keyword">super</span>(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">        FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            <span class="comment">// 可以看到调用了setState方法，也就是说AQS中的资源就是许可证的数量。</span></span><br><span class="line">            <span class="keyword">super</span>(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><h5 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h5><p><img src="images/cyclicbarrier-1.png" alt=""></p>
<p>&emsp;&emsp;<code>CyclicBarrier</code>也是一个同步辅助类，它允许一组线程相互等待， 直到到达某个公共的屏障点（common barrier point ），也称之为栅栏点。通过它可以完成多个线程之间相互等待，只有当每个线程都准备就绪后，才能各自继续进行后面的操作。它和<code>CountDownLatch</code>有相似的地方，都是通过计数器实现。当某个线程调用<code>await()</code>方法之后，该线程就进入等待状态，而且计数器是执行加一操作，当计数器值达到初始值（设定的值），因为调用<code>await()</code>方法进入等待的线程，会被唤醒，继续执行他们后续的操作。由于<code>CyclicBarrier</code>在等待线程释放之后，可以进行重用，所以称之为循环屏障。它非常适用于一组线程之间必需经常互相等待的情况。   </p>
<h5 id="与CountDownLatch比较"><a href="#与CountDownLatch比较" class="headerlink" title="与CountDownLatch比较"></a>与CountDownLatch比较</h5><p>&emsp;&emsp;<strong>相同点：</strong></p>
<ol>
<li>都是同步辅助类。</li>
<li>使用计数器实现</li>
</ol>
<p>&emsp;&emsp;<strong>不同点：</strong></p>
<ol>
<li><code>CountDownLatch</code>允许一个或多个线程，等待其他一组线程完成操作，再继续执行。 </li>
<li><code>CyclicBarrier</code>允许一组线程相互之间等待，达到一个共同点，再继续执行。 </li>
<li><code>CountDownLatch</code>不能被复用</li>
<li><code>CyclicBarrier</code>适用于更复杂的业务场景，如计算发生错误，通过重置计数器，并让线程重新执行</li>
<li><code>CyclicBarrier</code>还提供其他有用的方法，比如<code>getNumberWaiting</code>方法可以获得<code>CyclicBarrier</code>阻塞的线程数量。<code>isBroken</code>方法用来知道阻塞的线程是否被中断。 </li>
</ol>
<p>&emsp;&emsp;<strong>场景比较：</strong></p>
<ol>
<li><code>CyclicBarrier</code> : 好比一扇门，默认情况下关闭状态，堵住了线程执行的道路，直到所有线程都就位，门才打开，让所有线程一起通过。  </li>
<li><code>CyclicBarrier</code>可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个Excel保存了用户所有银行流水，每个Sheet保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日均银行流水，最后，再用<code>barrierAction</code>用这些线程的计算结果，计算出整个Excel的日均银行流水。  </li>
<li><code>CountDownLatch</code> : 监考老师发下去试卷，然后坐在讲台旁边玩着手机等待着学生答题，有的学生提前交了试卷，并约起打球了，等到最后一个学生交卷了，老师开始整理试卷，贴封条  </li>
</ol>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample1</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义屏障，指定数量为5个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">		<span class="comment">//往线程池中放入线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    race(threadNum);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">race</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125; is ready"</span>, threadNum);</span><br><span class="line">        <span class="comment">//如果当前线程就绪，则告诉CyclicBarrier 需要等待</span></span><br><span class="line">        barrier.await();</span><br><span class="line">        <span class="comment">// 当达到指定数量时，继续执行下面代码</span></span><br><span class="line">        log.info(<span class="string">"&#123;&#125; continue"</span>, threadNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>await()</code>支持多个参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    race(threadNum);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">race</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125; is ready"</span>, threadNum);</span><br><span class="line">       	<span class="comment">// 需要异常处理，否则不能进行等待后的代码</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//等待时间，继续执行，但需要进行异常的捕获，才能继续执行</span></span><br><span class="line">            barrier.await(<span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//尽可能捕捉所有的异常类型</span></span><br><span class="line">            log.warn(<span class="string">"BarrierException"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125; continue"</span>, threadNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 除了指定屏障数外，指定一个Runnable任务，</span></span><br><span class="line"><span class="comment">     * 意味着：在线程到达屏障时，优先执行Runnable任务，方便处理更复杂的业务场景</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.parties = parties;</span><br><span class="line">        <span class="keyword">this</span>.count = parties;</span><br><span class="line">        <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//常用的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">mport java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, () -&gt; &#123;</span><br><span class="line">        <span class="comment">//当达到线程屏障数5时，执行任务</span></span><br><span class="line">        <span class="comment">//每满足一次屏障数，则执行</span></span><br><span class="line">        log.info(<span class="string">"callback is running"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    race(threadNum);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">race</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125; is ready"</span>, threadNum);</span><br><span class="line">        barrier.await();</span><br><span class="line">        log.info(<span class="string">"&#123;&#125; continue"</span>, threadNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ReentrantLock-与-锁"><a href="#ReentrantLock-与-锁" class="headerlink" title="ReentrantLock 与 锁"></a>ReentrantLock 与 锁</h4><p>&emsp;&emsp;JAVA中的锁主要分两类：<code>synchronized</code>关键字 与 J.U.C所提供的锁。J.U.C中核心的锁即是<code>ReentrantLock</code>，本质上都是lock与unlock的操作 。  </p>
<h5 id="ReentrantLock-可重入锁-和synchronized区别"><a href="#ReentrantLock-可重入锁-和synchronized区别" class="headerlink" title="ReentrantLock(可重入锁)和synchronized区别"></a>ReentrantLock(可重入锁)和synchronized区别</h5><ul>
<li><p>可重入性：<code>ReentrantLock</code>字面意思即为再进入锁，称为可重入锁，其实<code>synchronize</code>所使用的锁也是可以重入的，两者关于这个区别不打，它们都是同一个线程进入一次，锁的计数器进行自增，要等到锁的计数器下降为零时，才能释放锁  </p>
</li>
<li><p>锁的实现：<code>synchronized</code>依赖于JVM实现无法了解底层源码，而<code>ReentrantLock</code>基于JDK实现通过阅读源码了解实现，区别就类似于操作系统控制实现与用户使用代码实现。  </p>
</li>
<li><p>性能区别：在<code>synchronized</code>优化以前，性能比<code>ReentrantLock</code>差很多，但自从<code>synchronize</code>引入了偏向锁、轻量级锁（自选锁）后 ，也就是自循锁后，两者性能差不多（JDK1.6以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”）。在两种场景下都可以使用，官方更推荐使用<code>synchronized</code>，因为写法更容易。<code>synchronized</code>的优化其实是借鉴了<code>ReentrantLock</code>中的CAS技术，都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。  </p>
</li>
<li><p>功能区别：</p>
<ul>
<li>便利性：<code>synchronized</code>更便利，它是由编译器保证加锁与释放。<code>ReentrantLock</code>是需要手动声明与释放锁，所以为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。   </li>
<li>锁的细粒度和灵活度：<code>ReentrantLock</code>优于<code>synchronized</code>  </li>
</ul>
</li>
<li><p>ReentrantLock独有的功能  </p>
<ul>
<li><code>ReentrantLock</code>可以指定是公平锁还是非公平锁，<code>synchronized</code>只能是非公平锁。（所谓公平锁就是先等待的线程先获得锁）  </li>
<li>提供了一个Condition类，可以分组唤醒需要唤醒的线程。不像是synchronized要么随机唤醒一个线程，要么全部唤醒。  </li>
<li>提供能够中断等待锁的线程的机制，通过<code>lock.lockInterruptibly()</code>实现，这种机制<code>ReentrantLock</code>是一种自选锁，通过循环调用CAS操作来实现加锁。性能比较好的原因是避免了进入内核态的阻塞状态。想进办法避免线程进入内核阻塞状态， 是我们分析和理解锁设计的关键  </li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;如果满足<code>ReentrantLock</code>三个独有的功能，那么必须使用<code>ReentrantLock</code>。其他情况下可以根据性能、业务场景等等来选择<code>synchronized</code>还是<code>ReentrantLock</code>  </p>
<h5 id="是否要放弃synchronized"><a href="#是否要放弃synchronized" class="headerlink" title="是否要放弃synchronized"></a>是否要放弃synchronized</h5><p>&emsp;&emsp;<code>synchronized</code>能做的，<code>ReentrantLock</code>都能做；而<code>ReentrantLock</code>能做的，而<code>synchronized</code>却不一定做得了。性能方面，<code>ReentrantLock</code>不比<code>synchronized</code>差，那么要放弃使用<code>synchronized</code>？  </p>
<ol>
<li>J.U.C包中的锁定类是用于高级情况和高级用户的工具，除非说你对Lock的高级特性有特别清楚的了解以及有明确的需要，或这有明确的证据表明同步已经成为可伸缩性的瓶颈的时候，否则我们还是继续使用synchronized   </li>
<li>相比较这些高级的锁定类，<code>synchronized</code>还是有一些优势的，比如synchronized不可能忘记释放锁。 在退出<code>synchronized</code>块时，JVM会自动释放锁，会很容易忘记要使用<code>finally</code>释放锁，这对程序非常有害。  </li>
<li>还有当JVM使用<code>synchronized</code>管理锁定请求和释放时，JVM在生成线程转储时能够包括锁定信息，这些信息对调试非常有价值，它们可以标识死锁以及其他异常行为的来源。 而<code>Lock</code>类知识普通的类，JVM不知道哪个线程具有<code>Lock</code>对象，而且几乎每个开发人员都是比较熟悉<code>synchronized</code>  </li>
</ol>
<h5 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明锁的实例,调用构造方法，默认生成一个不公平的锁 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ReentrantLock</code>提供了许多方法：  </p>
<ul>
<li><code>tryLock()</code>：仅在调用时锁定未被另一个线程保持的情况下才获取锁定。  </li>
<li><code>tryLock(long timeout, TimeUnit unit)</code>：如果锁定在给定的时间内没有被另一个线程保持且当前线程没有被中断，则获取这个锁定。  </li>
<li><code>lockInterruptbily()</code>：如果当前线程没有被中断的话，那么就获取锁定。如果中断了就抛出异常。  </li>
<li><code>isLocked()</code>：查询此锁定是否由任意线程保持  </li>
<li><code>isHeldByCurrentThread</code>：查询当前线程是否保持锁定状态。  </li>
<li><code>isFair</code>：判断是不是公平锁   </li>
</ul>
<h5 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 内部类提供的读锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">    <span class="comment">/** 内部类提供的读锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们可以看到<code>RenntrantLock</code>提供了<code>ReadLock</code>与<code>WriteLock</code>，在没有任何读写锁时，才可以取得写入锁。如果进行读取时，可能有另一个写入的需求，为了保持同步，读取锁定。  </p>
<p>&emsp;&emsp;<code>ReentrantReadWriteLock</code>写锁的互斥的，也就是说，读和读是不互斥的，但读和写、写和写是互斥的。  </p>
<p>&emsp;&emsp;在没有任何读写锁的时候才可以取得写入锁(悲观读取，容易写线程饥饿)，也就是说如果一直存在读操作，那么写锁一直在等待没有读的情况出现，这样我的写锁就永远也获取不到，就会造成等待获取写锁的线程饥饿。所以，此类不能乱用，在使用是一定要掌握其特性与实现方式。  </p>
<p>&emsp;&emsp;<code>ReentrantReadWriteLock</code>是<code>Lock</code>的另一种实现方式，我们已经知道了<code>ReentrantLock</code>是一个排他锁，同一时间只允许一个线程访问，而<code>ReentrantReadWriteLock</code>允许多个读线程同时访问，但不允许写线程和读线程、写线程和写线程同时访问。相对于排他锁，提高了并发性。在实际应用中，大部分情况下对共享数据（如缓存）的访问都是读操作远多于写操作，这时<code>ReentrantReadWriteLock</code>能够提供比排他锁更好的并发性和吞吐量。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="comment">//使用场景并不多</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Data&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明读写锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得读写锁中的读锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock readLock = lock.readLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得读写锁中的写锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock writeLock = lock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getAllKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.keySet();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">put</span><span class="params">(String key, Data value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可能导致线程饥饿，处于一直等待状态</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h5><p>&emsp;&emsp;在JDK1.8中，新增 <code>StampedLock</code> ，它是<code>ReentrantReadWriteLock</code>的增强版，是为了解决<code>ReentrantReadWriteLock</code>的一些不足。正因为<code>ReentrantReadWriteLock</code>出现了读和写是互斥的情况，需要优化，因此就出现了<code>StampedLock</code>！  </p>
<p>&emsp;&emsp;它控制锁有三种模式（写、读、乐观读）。一个<code>StempedLock</code>的状态是由版本和模式两个部分组成。锁获取方法返回一个数字作为票据（stamp），他用相应的锁状态表示并控制相关的访问。数字0表示没有写锁被锁写访问，在读锁上分为悲观锁和乐观锁。  </p>
<p>&emsp;&emsp;乐观读：  如果读的操作很多写的很少，我们可以乐观的认为读的操作与写的操作同时发生的情况很少，因此不悲观的使用完全的读取锁定。程序可以查看读取资料之后是否遭到写入资料的变更，再采取之后的措施。  </p>
<p>&emsp;&emsp;它的思想是读写锁中读不仅不阻塞读，同时也不应该阻塞写。 在读的时候如果发生了写，则应当重读而不是在读的时候直接阻塞写。使用<code>StampedLock</code>就可以实现一种无障碍操作，即读写之间不会阻塞对方，但是写和写之间还是阻塞的</p>
<p><strong>在源码中，提供一个使用<code>StampedLock</code>案例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> x, y;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123; <span class="comment">// an exclusively locked method</span></span><br><span class="line">            <span class="keyword">long</span> stamp = sl.writeLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                x += deltaX;</span><br><span class="line">                y += deltaY;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sl.unlockWrite(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面看看乐观读锁案例</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123; <span class="comment">// A read-only method</span></span><br><span class="line">            <span class="keyword">long</span> stamp = sl.tryOptimisticRead(); <span class="comment">//获得一个乐观读锁</span></span><br><span class="line">            <span class="keyword">double</span> currentX = x, currentY = y;  <span class="comment">//将两个字段读入本地局部变量</span></span><br><span class="line">            <span class="keyword">if</span> (!sl.validate(stamp)) &#123; <span class="comment">//检查发出乐观读锁后同时是否有其他写锁发生？</span></span><br><span class="line">                stamp = sl.readLock();  <span class="comment">//如果没有，我们再次获得一个读悲观锁</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    currentX = x; <span class="comment">// 将两个字段读入本地局部变量</span></span><br><span class="line">                    currentY = y; <span class="comment">// 将两个字段读入本地局部变量</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sl.unlockRead(stamp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面是悲观读锁案例</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">moveIfAtOrigin</span><span class="params">(<span class="keyword">double</span> newX, <span class="keyword">double</span> newY)</span> </span>&#123; <span class="comment">// upgrade</span></span><br><span class="line">            <span class="comment">// Could instead start with optimistic, not read mode</span></span><br><span class="line">            <span class="keyword">long</span> stamp = sl.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123; <span class="comment">//循环，检查当前状态是否符合</span></span><br><span class="line">                    <span class="keyword">long</span> ws = sl.tryConvertToWriteLock(stamp); <span class="comment">//将读锁转为写锁</span></span><br><span class="line">                    <span class="keyword">if</span> (ws != <span class="number">0L</span>) &#123; <span class="comment">//这是确认转为写锁是否成功</span></span><br><span class="line">                        stamp = ws; <span class="comment">//如果成功 替换票据</span></span><br><span class="line">                        x = newX; <span class="comment">//进行状态改变</span></span><br><span class="line">                        y = newY;  <span class="comment">//进行状态改变</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果不能成功转换为写锁</span></span><br><span class="line">                        sl.unlockRead(stamp);  <span class="comment">//我们显式释放读锁</span></span><br><span class="line">                        stamp = sl.writeLock();  <span class="comment">//显式直接进行写锁 然后再通过循环再试</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sl.unlock(stamp); <span class="comment">//释放读锁或写锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="如何选择锁？"><a href="#如何选择锁？" class="headerlink" title="如何选择锁？"></a>如何选择锁？</h5><p>&emsp;&emsp;<code>synchronized</code>是JVM层面的，通过底层监控工具监控<code>synchronized</code>的锁定，出现异常会自动释放锁，JVM实现自动的加锁与解锁。  </p>
<p>&emsp;&emsp;<code>Lock</code>是对象级的锁定，要保证锁一定要被释放。<code>StampedLock</code>对吞吐量有巨大的改进，特别是在读线程越来越多的场景下。</p>
<ul>
<li>当只有少量竞争者，使用<code>synchronized</code>是很明智的选择</li>
<li>竞争者不少但是线程增长的趋势是能预估的，使用<code>ReetrantLock</code></li>
<li>使用锁一定要看是否适应场景，并不是哪个高级用哪个。</li>
<li><code>synchronized</code>不会引发死锁，如果<code>Lock</code>使用不当可能造成死锁 </li>
</ul>
<h5 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h5><p>&emsp;&emsp;<code>Condition</code>是一个多线程间协调通信的工具类，在前面AQS底层数据结果分析时提到除了AQS自身队列之外，还有可能存在<code>Condition</code>队列（不存在或者存在一个以上，即多个等待队列）。  </p>
<p>&emsp;&emsp;使得某个，或者某些线程一起等待某个条件（Condition）,只有当该条件具备( signal 或者 signalAll方法被带调用)时 ，这些等待线程才会被唤醒，从而重新争夺锁。  </p>
<p>&emsp;&emsp;<code>Condition</code>是同步器<code>AbstractQueuedSynchronized</code>的内部类，因为<code>Condition</code>的操作需要获取相关的锁，所以作为同步器的内部类比较合理。每个<code>Condition</code>的关键。  </p>
<p>&emsp;&emsp;一个 <code>Condition</code> 包含一个等待队列，<code>Condition</code>拥有首节点<code>firstWaiter</code>和尾节点<code>lastWaiter</code>。当前线程调用<code>Condition.await()</code>方法时，将会以当前线程构造节点，并将节点从尾部加入等待队列。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="comment">//从ReentrantLock中取得Condition对象</span></span><br><span class="line">        <span class="comment">//此时在AQS中生成Condition队列（可以有多个）</span></span><br><span class="line">        Condition condition = reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//加入AQS的等待队列里</span></span><br><span class="line">                reentrantLock.lock();</span><br><span class="line">                <span class="comment">//输出等待信号动作</span></span><br><span class="line">                log.info(<span class="string">"wait signal"</span>); <span class="comment">// 1</span></span><br><span class="line">                <span class="comment">//线程1沉睡，从AQS等待队列中移除，对应的操作即是锁的释放，然后加入Condition队列中</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">"get signal"</span>); <span class="comment">// 4</span></span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//因为线程1释放锁，这时得到锁</span></span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            log.info(<span class="string">"get lock"</span>); <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//发送信号，这时Condition队列中有线程1的结点，被取出加入AQS等待队列（注意，线程1没有被唤醒）</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">            log.info(<span class="string">"send signal ~ "</span>); <span class="comment">// 3</span></span><br><span class="line">            <span class="comment">//释放锁会唤醒AQS队列</span></span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Condition作为一个条件类，很好的维护了一个等待信号的队列，并在适合的时候，将自身队列中的</span></span><br><span class="line"><span class="comment">     * 结点加入到AQS等待队列中，实现唤醒操作。使得某个线程等待某个条件，实际上使用很少</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="index-post card" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/21/concurrency/concurrency-3/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="龙门小左">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="程序猿的日常">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2018/06/21/concurrency/concurrency-3/" itemprop="url">JAVA并发编程与高并发解决方案 - 并发编程 三</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2018-06-21T10:00:00+08:00">2018-06-21 10:00:00</time></span>
        </span>
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="JAVA并发编程与高并发解决方案-并发编程-三"><a href="#JAVA并发编程与高并发解决方案-并发编程-三" class="headerlink" title="JAVA并发编程与高并发解决方案 - 并发编程 三"></a>JAVA并发编程与高并发解决方案 - 并发编程 三</h1><table>
<thead>
<tr>
<th style="text-align:center">版本</th>
<th style="text-align:center">作者</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2018.4.8</td>
<td style="text-align:center">chuIllusions</td>
<td style="text-align:center">线程安全策略</td>
</tr>
</tbody>
</table>
<h3 id="线程安全策略"><a href="#线程安全策略" class="headerlink" title="线程安全策略"></a>线程安全策略</h3><p>​    创建后状态不能被修改的对象叫作不可变对象。不可变对象天生就是线程安全的。它们的常量（变量）是在构造函数中创建的，既然它们的状态无法被修改，那么这些常量永远不会被改变——不可变对象永远是线程安全的。</p>
<p>不可变对象需要满足的条件</p>
<ul>
<li>对象创建以后其状态就不能修改</li>
<li>对象所有域都是final类型</li>
<li>对象是正确创建的（在对象创建期间，this引用没有逸出）</li>
</ul>
<h4 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h4><h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><p>​    final关键字：类、方法、变量</p>
<ul>
<li>修饰类：不能被继承，final类中的成员属性可以根据需要设置为final，但final类中所有的成员方法都被隐式指定为final方法。一般不建议将类设置为final类型。可以参考String类。</li>
<li>修饰方法：1）锁定方法不被继承类修改；2）效率</li>
<li>修饰变量：1）基本数据类型变量，初始化后便不能进行修改；2）引用类型变量，初始化之后不能再指向别的引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Integer a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String b = <span class="string">"2"</span>;</span><br><span class="line">    <span class="comment">//引用类型不允许引用指向改变，但是对象值还是可以进行修改的  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        a = 2;              //编译时报错</span></span><br><span class="line"><span class="comment">//        b = "3";            //编译时报错</span></span><br><span class="line"><span class="comment">//        map = Maps.newHashMap();   //编译时报错</span></span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">3</span>);       <span class="comment">//容易引发线程安全问题</span></span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, map.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以修饰参数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        a = 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h5><p>​    java提供Collections工具类，在类中提供了多种不允许修改的方法</p>
<p>​    Collections.unmodifiableXXX：Collection、List、Set、Map…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">//处理过后的map是不可以再进行修改的</span></span><br><span class="line">        map = Collections.unmodifiableMap(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//允许操作，但是操作会报错，扔出异常</span></span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, map.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collections</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">unmodifiableMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UnmodifiableMap&lt;&gt;(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnmodifiableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Guava"><a href="#Guava" class="headerlink" title="Guava"></a>Guava</h5><p>​    谷歌的Guava提供类似Java中的Collections</p>
<p>​    ImmutableXXX：Collection、List、Set、Map…</p>
<p><code>pom.xml</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>23.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableList&lt;Integer&gt; list = ImmutableList.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;Integer&gt; lists = ImmutableList.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableSet set = ImmutableSet.copyOf(list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableMap&lt;Integer, Integer&gt; map = ImmutableMap.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableMap&lt;Integer, Integer&gt; map2 = ImmutableMap.&lt;Integer, Integer&gt;builder()</span><br><span class="line">            .put(<span class="number">1</span>, <span class="number">2</span>).put(<span class="number">3</span>, <span class="number">4</span>).put(<span class="number">5</span>, <span class="number">6</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(map2.get(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    介绍了不可变对象，通过在某些情况下，将不能被修改的类对象，设置为不可变对象，来让对象在多个线程间是线程安全的。归根到底，其实是躲避开了并发的问题。除了不可变对象，还存在一个方法 就是线程封闭</p>
<h4 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h4><p>​    把对象封装到一个线程里，只有这一个线程能看到该对象，那么就算这个对象不是线程安全的，也不会出现任何线程安全的问题，因为它只能在一个线程中被访问，如何实现线程封闭：</p>
<ul>
<li>Ad-hoc 线程封闭：程序控制实现，非常脆弱、最糟糕，忽略</li>
<li>堆栈封闭：简单的说就是局部变量，无并发问题。多个线程访问同一个方式的时候，方法中的局部变量都会被拷贝一份到线程栈中，方法的局部变量是不被多个线程共享的，因此不会出现线程安全问题，能用局部变量就不推荐使用全局变量，全局变量容易引起并发问题，注意，全局的变量而不是全局的常量。</li>
<li>ThreadLocal 线程封闭：特别好的封闭方法</li>
</ul>
<h5 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This class provides thread-local variables.  These variables differ from</span></span><br><span class="line"><span class="comment"> * their normal counterparts in that each thread that accesses one (via its</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> get&#125; or &#123;<span class="doctag">@code</span> set&#125; method) has its own, independently initialized</span></span><br><span class="line"><span class="comment"> * copy of the variable.  &#123;<span class="doctag">@code</span> ThreadLocal&#125; instances are typically private</span></span><br><span class="line"><span class="comment"> * static fields in classes that wish to associate state with a thread (e.g.,</span></span><br><span class="line"><span class="comment"> * a user ID or Transaction ID).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>​    从类描述上:ThreadLocal提供线程级别的变量.这些变量不同于它们正常下的变量副本,在每一个线程中都有它自己获取方式(通过它的get和set方法)，不依赖变量副本的初始化。它的实例通常都是私有的静态的，用于关联线程的上下文。</p>
<p>​    这些变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量</p>
<p>​    <strong>总结：ThreadLocal的作用是提供线程内部的局部变量，这种变量只存在线程的生命周期。</strong></p>
<p>声明方式：<code>private static ThreadLocal&lt;Object&gt; threadLocal = new ThreadLocal&lt;Object&gt;;</code></p>
<h6 id="类分析"><a href="#类分析" class="headerlink" title="类分析"></a>类分析</h6><p>​    ThreadLocal涉及到的类结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(C)ThreadLocal</span><br><span class="line">	-&gt; (C)ThreadLocalMap</span><br><span class="line">		-&gt; (C)Entry</span><br><span class="line">(C)Thread</span><br><span class="line">	-&gt; (f)ThreadLocal.ThreadLocalMap</span><br></pre></td></tr></table></figure>
<p><code>Thread.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    其中<code>ThreadLocalMap</code>类的定义是在<code>ThreadLocal</code>类中，真正的引用却是在<code>Thread</code>类中。同时，<code>ThreadLocalMap</code>中用于存储数据的entry定义：</p>
<p><code>ThreadLocal.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line">		   <span class="comment">//key为ThreadLocal对象，value为存储的值</span></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>ThreadLocalMap的key</code>是<code>ThreadLocal</code>类的实例对象，value为用户的值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//设置值的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//2.从线程中获取该线程的成员属性 ThreadLocal.ThreadLocalMap</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="comment">//将值放入Map中</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//先创建，在设置值</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取值的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果没有设置，会调用，设置一个value为null</span></span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h6><p>​    从上面的源码分析，我们可以得出<code>ThreadLocal</code>的工作原理如下</p>
<ul>
<li>声明全局的<code>ThreadLocal</code>变量，<code>private static ThreadLocal&lt;Object&gt; threadLocal = new ThreadLocal&lt;Object&gt;;</code></li>
<li>每个线程中都有属于自己的<code>ThreadLocalMap</code>，互不干扰</li>
<li>全局只有一个<code>threadLocal</code>，当通过<code>set</code>填充数据时，通过获取当前操作线程的<code>threadLocalMap</code>，将<code>threadLocal</code>作为<code>threadLocalMap</code>中的<code>key</code>，需要填充的值作为<code>value</code></li>
<li><p>当需要从<code>threadLocal</code>获取值时，通过获取当前操作线程的<code>threadLocalMap</code>，并返回<code>key</code>为<code>threadLocal</code>对象的value</p>
<pre><code>那么就可以理解为：`ThreadLocal`的活动范围是具体的某一个线程，并且是该线程独有的。它不是用来解决共享变量的多线程安全问题。

但是，有一点需要说明的是，如果`ThreadLocal`通过`set`方法放进去的值，这个值是共享对象，那么还是会存在线程安全问题。
</code></pre></li>
</ul>
<h6 id="多个-ThreadLocal"><a href="#多个-ThreadLocal" class="headerlink" title="多个 ThreadLocal"></a>多个 ThreadLocal</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于唯一确认一个ThreadLocal对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>引用于<a href="https://www.cnblogs.com/xzwblog/p/7227509.html" target="_blank" rel="noopener">彻底理解ThreadLocal</a></p>
<p>如何保证两个同时实例化的<code>ThreadLocal</code>对象有不同的<code>threadLocalHashCode</code>属性：在<code>ThreadLocal</code>类中，还包含了一个static修饰的<code>AtomicInteger</code>（[əˈtɒmɪk]提供原子操作的Integer类）成员变量（即类变量）和一个static final 修饰的常量（作为两个相邻<code>nextHashCode</code>的差值）。由于<code>nextHashCode</code>是类变量，所以每一次调用<code>ThreadLocal</code>类都可以保证<code>nextHashCode</code>被更新到新的值，并且下一次调用<code>ThreadLocal</code>类这个被更新的值仍然可用，同时<code>AtomicInteger</code>保证了<code>nextHashCode</code>自增的原子性。</p>
</blockquote>
<p>​    <code>ThreadLocal</code>中的<code>ThreadLocalMap</code>中的<code>key</code>为<code>ThreadLocal</code>对象，由于每个实例化的<code>ThreadLocal</code>对象都是不相同的，所以不会存在<code>key</code>冲突，所以一个线程存在多个<code>ThreadLocal</code>对象作为<code>key</code>是完全没有问题的。也就是说，一个线程中的<code>ThreadLocalMap</code>可以存在多个<code>key</code>。</p>
<p>​    为什么使用<code>ThreadLocal</code>作为<code>ThreadLocalMap</code>的<code>key</code>? 上面的解析已经很明确了。</p>
<p>​    试试使用线程<code>id</code>作为<code>ThreadLocalMap</code>的<code>key</code>? 如果使用线程<code>id</code>作为<code>key</code>，如果存在两个<code>ThreadLocal</code>对象，一个存放<code>String</code>类型，另一个存放<code>Integer</code>类型，而在单个线程中只存在一个<code>ThreadLocalMap</code>，当存放数据时，<code>key</code>永远只会有一个（线程id），存入数据的时候先存会被后存覆盖，获取数据时候可能会发生错误。</p>
<h6 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h6><p>​    ThreadLocal中存放的变量只在线程的生命周期内起作用，应用场景只要有两个方面：</p>
<ol>
<li>提供一个线程内公共变量（比如本次请求的用户信息、实体参数），减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度</li>
<li>为线程提供一个私有的变量副本，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</li>
</ol>
<h6 id="关于内存泄露"><a href="#关于内存泄露" class="headerlink" title="关于内存泄露"></a>关于内存泄露</h6><p>​    首先，得分析一下内存泄露是什么东西，Java内存泄露又是怎么定义的？</p>
<blockquote>
<p>内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，<strong>造成系统内存的浪费</strong>，导致程序运行速度减慢甚至系统崩溃等严重后果。</p>
</blockquote>
<p>​    在Java程序中，我们通常使用new为对象分配内存，而这些内存空间都在堆（Heap）上。</p>
<p>​    JAVA内存的分配是由程序完成的，而内存的释放是由GC完成。在JAVA达到内存泄露的存在两个特点，满足以下两个条件，即可认为是JAVA内存泄露，这些对象不被GC管理、回收，占用内存。</p>
<ol>
<li>对象是可达的，即对象引用存在</li>
<li>对象无用的，即对象已经不再使用</li>
</ol>
<p>当达到内存泄露时，扔出的异常：<code>java.lang.OutOfMemoryError：Java heap space</code></p>
<p><strong><code>ThreadLocal</code>对象之间的引用关系图</strong></p>
<p><img src="images/threadlocal-ref.png" alt=""></p>
<p>下面引用知乎的一篇文章（<a href="https://www.zhihu.com/question/23089780" target="_blank" rel="noopener">ThreadLocal和synchronized的区别?</a>）进行说明：</p>
<blockquote>
<p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：ThreadLocal Ref -&gt; Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄露。</p>
</blockquote>
<p>分析ThreadLocalMap中的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据ThreadLocal对象获取Entry</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  key the thread local object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//计算索引位置</span></span><br><span class="line">     <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">     Entry e = table[i];</span><br><span class="line">     <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">          <span class="keyword">return</span> e;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         <span class="comment">//没有找到相应的entry</span></span><br><span class="line">          <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Version of getEntry method for use when key is not found in</span></span><br><span class="line"><span class="comment"> * its direct hash slot.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  key the thread local object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  i the table index for key's hash code</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  e the entry at table[i] 可能为null或者不为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取ThreadLocal对象</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">//如果e为null或者key不一致则向下一个位置查询</span></span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Expunge a stale entry by rehashing any possibly colliding entries</span></span><br><span class="line"><span class="comment"> * lying between staleSlot and the next null slot.  This also expunges</span></span><br><span class="line"><span class="comment"> * any other stale entries encountered before the trailing null.  See</span></span><br><span class="line"><span class="comment"> * Knuth, Section 6.4</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> staleSlot index of slot known to have null key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the index of the next null slot after staleSlot</span></span><br><span class="line"><span class="comment"> * (all between staleSlot and this slot will have been checked</span></span><br><span class="line"><span class="comment"> * for expunging).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果key值为null，则擦除该位置的Entry，否则继续向下一个位置查询</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。 但是光这样还是不够的，上面的设计思路依赖一个前提条件：<strong>要调用ThreadLocalMap的genEntry函数或者set</strong>函数。这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。</p>
</blockquote>
<h6 id="项目应用"><a href="#项目应用" class="headerlink" title="项目应用"></a>项目应用</h6><p>​    为了避免每个封装后的参数从controller层传递到service层，再从service层传递到dao层，或者从service层传递到其他的工具类当中。我在项目中使用ThreadLocal的思路是这样的：</p>
<p>​    由于避免参数复杂的传递，在controller中将已经封装好的参数放入ThreadLocal中，在其他层调用时直接通过ThreadLocal对象获取。在方法结束时，定义拦截器（或者Filter）进行ThreadLocal的remove方法。</p>
<h4 id="常见线程不安全类与写法"><a href="#常见线程不安全类与写法" class="headerlink" title="常见线程不安全类与写法"></a>常见线程不安全类与写法</h4><p>​    什么是线程不安全的类呢？简单的说，如果一个类的对象同时可以被多个线程访问，如果不做特殊的同步或并发处理，那么就很容易表现出线程不安全的现象，比如异常、逻辑处理错误等等，这种类称之为线程不安全的类。</p>
<h5 id="StringBuilder-与-StringBuffer"><a href="#StringBuilder-与-StringBuffer" class="headerlink" title="StringBuilder 与 StringBuffer"></a>StringBuilder 与 StringBuffer</h5><h6 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, stringBuilder.length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stringBuilder.append(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    main函数中输出的结果不为预期的5000，并且每次结果可能会不一致，因此<code>StringBuilder</code>是线程不安全类</p>
<h6 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, stringBuffer.length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stringBuffer.append(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <code>StringBuffer</code>每次输出的结果与预期结果一致，因此它是线程安全的类</p>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>​    通过以上两个例子可以知道，<code>StringBuffer</code>为线程安全类，<code>StringBuilder</code>为线程不安全类。</p>
<p>​    <code>StringBuffer</code>在方法的实现上使用了<code>synchronized</code>关键字对方法进行同步，因此是线程安全的，而<code>StringBuilder</code>则没有进行特殊的同步或并发处理。</p>
<p>​    <code>StringBuffer</code>使用了同步锁，同一时间只能有一个线程进行访问，因为在系统性能会有损耗，适用于多线程环境下使用。通常情况下，字符串拼接出现在方法内，使用<code>StringBuilder</code>进行字符串的拼接会大大提高性能，属于堆栈封闭，单个线程的操作对象，因此不存在线程不安全问题，优先选择使用<code>StringBuilder</code>。两种字符串拼接类分别适用不同的场景，这就是为什么JAVA同时提供了这两种类。</p>
<h5 id="SimpleDateFormat-与-JodaTime"><a href="#SimpleDateFormat-与-JodaTime" class="headerlink" title="SimpleDateFormat 与 JodaTime"></a>SimpleDateFormat 与 JodaTime</h5><h6 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h6><p>​    <code>SimpleDateFormat</code>是JAVA提供的一个日期转换类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormatExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            simpleDateFormat.parse(<span class="string">"20180208"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"parse exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    当方法运行的时候，则会抛出异常，原因是<code>SimpleDateFormat</code>在多线程下共享使用就会出现线程不安全情况。建议将<code>SimpleDateFormat</code>声明为局部变量，这样才会避免线程不安全所带来的异常</p>
<h6 id="JodaTime"><a href="#JodaTime" class="headerlink" title="JodaTime"></a>JodaTime</h6><p>​    线程安全的日期格式化</p>
<p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.joda.time.DateTime;</span><br><span class="line"><span class="keyword">import</span> org.joda.time.format.DateTimeFormat;</span><br><span class="line"><span class="keyword">import</span> org.joda.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormatExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;, &#123;&#125;"</span>, i, DateTime.parse(<span class="string">"20180208"</span>, dateTimeFormatter).toDate());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为线程安全的。</p>
<h6 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h6><p>​    在使用日期转换的时候，更建议使用JodaTime所提供的日期转换类，不仅是因为它是线程安全的，而且在类实际处理转换中有其他的优势。</p>
<h5 id="ArrayList、HashSet、HashMap-等-Collections"><a href="#ArrayList、HashSet、HashMap-等-Collections" class="headerlink" title="ArrayList、HashSet、HashMap 等 Collections"></a>ArrayList、HashSet、HashMap 等 Collections</h5><p>​    通常使用以上类，都是声明在方法内，作为局部变量使用，一般很少碰上线程不安全的问题。但如果定义为可以多个线程修改的时候，就会出现线程安全问题。</p>
<h6 id="List"><a href="#List" class="headerlink" title="List"></a>List</h6><p>多线程访问<code>ArrayList</code>会存在线程安全问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="comment">// 如果线程安全的话，理论上 list.size == clientTotal</span></span><br><span class="line">        <span class="comment">// 最后输出结果不为总产长度</span></span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h6><p>多线程操作<code>HashSet</code>也会存在线程安全问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="comment">// 如果线程安全的话，理论上 set.size == clientTotal</span></span><br><span class="line">        <span class="comment">// 输出的长度不一致</span></span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, set.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存在线程不安全问题</span></span><br><span class="line">        set.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h6><p>多线程操作<code>HashMap</code>也会存在线程安全问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="comment">// 如果线程安全的话，理论上 map.size == clientTotal</span></span><br><span class="line">        <span class="comment">// 输出结果不一致，并且少于预期值</span></span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, map.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        map.put(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="先检查在执行：if（condition-a-）-handle-a"><a href="#先检查在执行：if（condition-a-）-handle-a" class="headerlink" title="先检查在执行：if（condition(a)）{ handle(a) }"></a>先检查在执行：if（condition(a)）{ handle(a) }</h5><p>​    假设a为线程安全类或属性，如<code>AtomicInteger</code>。当存在两个线程都通过了<code>condition(a)</code>返回<code>true</code>，接下来分别处理a，即会触发线程不安全问题。这里，它的不安全的点在于分成两个操作之后，即使<code>condition(a)</code>，<code>handle(a)</code>两个操作都是线程安全的，但在执行的时候，并不是原子性的，因此则会引发线程不安全问题。</p>
<p>​    如果在项目中遇到这种处理，a为多线程共享，则需要在上面代码之外进行加锁，或者保证这两个连续的操作时原子性的。</p>
<h4 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h4><p>​    在上面线程不安全类中，提到了<code>ArrayList</code>、<code>HashSet</code>、<code>HashMap</code>非线程安全的容器，如果有多个线程并发的访问，就会出现线程安全问题，因此在编写程序的时候，必须要求开发人员手动的在任何访问这些容器的地方进行同步处理，导致使用这些容器非常不便，因此JAVA中提供同步容器。</p>
<ul>
<li>ArrayList -&gt; Vector、Stack</li>
<li>HashMap -&gt; HashTable(key、value均不能为null)</li>
<li><p>Collections.synchronizedXXX(List、Set、Map)</p>
<pre><code>`Vector`实现`List`接口，底层和`ArrayList`类似，但是`Vector`中的方法都是使用`synchronized`修饰，即进行了同步的措施。 但是，`Vector`并不是线程安全的。

`Stack`也是一个同步容器，也是使用`synchronized`进行同步，继承与`Vector`，是数据结构中的，先进后出。

`HashTable`和`HashMap`很相似，但`HashTable`进行了同步处理。

`Collections`工具类提供了大量的方法，比如对集合的排序、查找等常用的操作。同时也通过了相关了方法创建同步容器类
</code></pre></li>
</ul>
<h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子的写法是线程安全的</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是线程安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>同步容器不一定是线程安全的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Thread thread1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        vector.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            Thread thread2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        vector.get(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            thread1.start();</span><br><span class="line">            thread2.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <code>VectorExample2</code>程序的运行，在<code>get()</code>中会不断的抛出<code>ArrayIndexOutOfBoundsException</code>。<code>Vector</code>是线程同步容器，<code>size()</code>、<code>get()</code>与<code>remove()</code>都是被<code>synchronized</code>修饰的，但是为什么还是会存在线程安全问题呢？</p>
<p>​    首先，<code>get()</code>抛出的异常肯定是<code>remove()</code>引起的，<code>Vector</code>虽然能保证同一时刻，只能有一个线程进入访问。但是不排除有以下可能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 线程1和线程2都执行完vector.size()，获得的size大小相同，并且当两个线程都是i = 9</span></span><br><span class="line"><span class="comment">//2. 线程1执行remove操作，删除索引为9的数据</span></span><br><span class="line"><span class="comment">//3. 线程2执行get操作，获取索引为9的数据，那么就会抛出数组越界异常，</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">    <span class="comment">//线程1</span></span><br><span class="line">      vector.remove(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">    <span class="comment">//线程2</span></span><br><span class="line">       vector.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    在使用同步容器的时候，并不是所有的场合下都能够做到线程安全。</p>
<h5 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTableExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="comment">//输出结果与预期一致</span></span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, map.size());</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//此写法是线程安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        map.put(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Collections-1"><a href="#Collections-1" class="headerlink" title="Collections"></a>Collections</h5><h6 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// List同步容器构造</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = Collections.synchronizedList(Lists.newArrayList());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造同步HashSet</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;Integer&gt; set = Collections.synchronizedSet(Sets.newHashSet());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, set.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        set.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造同步HashMap</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, map.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        map.put(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="集合的删除"><a href="#集合的删除" class="headerlink" title="集合的删除"></a>集合的删除</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// java.util.ConcurrentModificationException</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(Vector&lt;Integer&gt; v1)</span> </span>&#123; <span class="comment">// foreach</span></span><br><span class="line">        <span class="keyword">for</span>(Integer i : v1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i.equals(<span class="number">3</span>)) &#123;</span><br><span class="line">                v1.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// java.util.ConcurrentModificationException</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(Vector&lt;Integer&gt; v1)</span> </span>&#123; <span class="comment">// iterator</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = v1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer i = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (i.equals(<span class="number">3</span>)) &#123;</span><br><span class="line">                v1.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在使用foreach或iterator进集合的遍历，</span></span><br><span class="line"><span class="comment">     * 尽量不要在操作的过程中进行remove等相关的更新操作。</span></span><br><span class="line"><span class="comment">     * 如果非要进行操作，则可以在遍历的过程中记录需要操作元素的序号，</span></span><br><span class="line"><span class="comment">     * 待遍历结束后方可进行操作，让这两个动作分开进行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">(Vector&lt;Integer&gt; v1)</span> </span>&#123; <span class="comment">// for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v1.get(i).equals(<span class="number">3</span>)) &#123;</span><br><span class="line">                v1.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        vector.add(<span class="number">1</span>);</span><br><span class="line">        vector.add(<span class="number">2</span>);</span><br><span class="line">        vector.add(<span class="number">3</span>);</span><br><span class="line">        test1(vector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    在单线程会出现以上错误，在多线程情况下，并且集合时共享的，出现异常的概率会更大，需要特别的注意。解决方案是希望在foreach或iterator时，对要操作的元素进行标记，待循环结束之后，在执行相关操作。</p>
<p>​    以上例子中，for循环是能正确的进行，因此推荐使用for循环做来做包含更新操作的便利</p>
<h5 id="同步容器总结"><a href="#同步容器总结" class="headerlink" title="同步容器总结"></a>同步容器总结</h5><p>​    同步容器中的方法主要采取<code>synchronized</code>进行同步，因此执行的性能会收到受到影响，并且同步容器并不一定能做到真正的线程安全。</p>
<h4 id="并发容器-J-U-C"><a href="#并发容器-J-U-C" class="headerlink" title="并发容器 J.U.C"></a>并发容器 J.U.C</h4><p>​    所谓的J.U.C其实是JDK所提供的一个包名，全程为<code>java.util.concurrent</code>,里面提供了许多线程安全的集合。</p>
<h5 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h5><h6 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h6><p>​    ArrayList -&gt; CopyOnWriteArrayList  ， ，<code>CopyOnWriteArrayList</code>相比于<code>ArrayList</code>是线程安全的，从字面意思理解，即为写操作时复制。<code>CopyOnWriteArrayList</code>使用了一种叫写时复制的方法，当有新元素添加到<code>CopyOnWriteArrayList</code>时，先从原有的数组中拷贝一份出来，然后在新的数组做写操作，写完之后，再将原来的数组引用指向到新数组。</p>
<p>​    <code>CopyOnWriteArrayList</code>的整个add操作都是在锁的保护下进行的。 这样做是为了避免在多线程并发add的时候，复制出多个副本出来,把数据搞乱了，导致最终的数组数据不是我们期望的。</p>
<p>​    本节介绍的内容，大部分参考来源于<a href="https://blog.csdn.net/linsongbin1/article/details/54581787" target="_blank" rel="noopener">线程安全的CopyOnWriteArrayList介绍</a></p>
<h6 id="Shortcoming"><a href="#Shortcoming" class="headerlink" title="Shortcoming"></a>Shortcoming</h6><ol>
<li><p>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致<code>young gc</code>或者<code>full gc</code></p>
</li>
<li><p>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个set操作后，读取到数据可能还是旧的,虽然<code>CopyOnWriteArrayList</code>能做到最终一致性,但是还是没法满足实时性要求；</p>
<p>​    <code>CopyOnWriteArrayList</code> 合适<strong>读多写少</strong>的场景，不过这类慎用  因为谁也没法保证<code>CopyOnWriteArrayList</code> 到底要放置多少数据，万一数据稍微有点多，每次add/set都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。 </p>
</li>
</ol>
<h6 id="Design-Thinking"><a href="#Design-Thinking" class="headerlink" title="Design Thinking"></a>Design Thinking</h6><ol>
<li>读写分离，读和写分开 </li>
<li>最终一致性。最终保证<code>List</code>的结果是对的</li>
<li>使用另外开辟空间的思路，来解决并发冲突</li>
</ol>
<h6 id="Read-Operation"><a href="#Read-Operation" class="headerlink" title="Read Operation"></a>Read Operation</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 添加元素的操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获得锁</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();<span class="comment">//获得当前的数组</span></span><br><span class="line">            <span class="keyword">int</span> len = elements.length;<span class="comment">//获取数组长度</span></span><br><span class="line">            <span class="comment">//进行数组的复制</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//添加新元素</span></span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            <span class="comment">//引用指向更改</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        	<span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    由于所有的写操作都是在新数组进行的，这个时候如果有线程并发的写，则通过锁来控制，如果有线程并发的读，则分几种情况： </p>
<ol>
<li>如果写操作未完成，那么直接读取原数组的数据； </li>
<li>如果写操作完成，但是引用还未指向新数组，那么也是读取原数组数据； </li>
<li>如果写操作完成，并且引用已经指向了新的数组，那么直接从新数组中读取数据。</li>
</ol>
<p>注意：<code>CopyOnWriteArrayList</code>的读操作是可以不用加锁的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Using"><a href="#Using" class="headerlink" title="Using"></a>Using</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayListExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, list.size());</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h5><p>​    HashSet -&gt; CopyOnWriteArraySet </p>
<p><code>CopyOnWriteArraySet</code>底层实现是采用<code>CopyOnWriteArrayList</code>，合适比较小的集合，其中所有可变操作（add、set、remove等等）都是通过对底层数组进行一次新的复制来实现的,一般需要很大的开销。迭代器支持hasNext(), next()等不可变操作，不支持可变的<code>remove</code>操作；使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArraySetExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;Integer&gt; set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, set.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        set.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a>ConcurrentSkipListSet</h5><p>​    TreeSet -&gt; ConcurrentSkipListSet</p>
<ul>
<li><code>ConcurrentSkipListSet&lt;E&gt;</code>是jdk6新增的类，位于java.util.concurrent并发库下 </li>
<li><code>ConcurrentSkipListSet&lt;E&gt;</code>和<code>TreeSet</code>一样，都是支持自然排序，并且可以在构造的时候定义<code>Comparator&lt;E&gt;</code>的比较器，该类的方法基本和<code>TreeSet</code>中方法一样（方法签名一样）</li>
<li>和其他的Set集合一样，<code>ConcurrentSkipListSet&lt;E&gt;</code>都是基于<code>Map</code>集合的，<code>ConcurrentSkipListMap</code>便是它的底层实现</li>
<li>在多线程的环境下，<code>ConcurrentSkipListSet&lt;E&gt;</code>中的<code>contains</code>、<code>add</code>、<code>remove</code>操作是安全的，多个线程可以安全地并发执行插入、移除和访问操作。但是对于批量操作<code>addAll</code>、<code>removeAll</code>、<code>retainAll</code> 和 <code>containsAll</code>并不能保证以原子方式执行。理由很简单，因为<code>addAll</code>、<code>removeAll</code>、<code>retainAll</code>底层调用的还是<code>contains</code>、<code>add</code>、<code>remove</code>的方法，在批量操作时，只能保证每一次的<code>contains</code>、<code>add</code>、<code>remove</code>的操作是原子性的（即在进行<code>contains</code>、<code>add</code>、<code>remove</code>三个操作时，不会被其他线程打断），而不能保证每一次批量的操作都不会被其他线程打断。因此，在<code>addAll</code>、<code>removeAll</code>、<code>retainAll</code> 和 <code>containsAll</code>操作时，需要添加额外的同步操作。</li>
<li>此类不允许使用 null 元素，因为无法可靠地将 null 参数及返回值与不存在的元素区分开来</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSkipListSetExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;Integer&gt; set = <span class="keyword">new</span> ConcurrentSkipListSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, set.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        set.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h5><p>​    HashMap -&gt; ConcurrentHashMap ，不允许<code>null</code>值，绝大部分使用<code>Map</code>都是读取操作，而且读操作大多数都是成功的，因此，<code>ConcurrentHashMap</code>针对读操作进行了大量的优化。在高并发的场景下，有很大的优势。</p>
<p>​    内容参考<a href="http://www.importnew.com/26049.html" target="_blank" rel="noopener">深入并发包 ConcurrentHashMap</a></p>
<p>​    因为多线程环境下，使用<code>Hashmap</code>进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用<code>HashMap</code>。 <code>HashMap</code>在put的时候，插入的元素超过了容量（由负载因子决定）的范围就会触发扩容操作，就是<code>rehash</code>，这个会重新将原数组的内容重新<code>hash</code>到新的扩容数组中，在多线程的环境下，存在同时其他的元素也在进行<code>put</code>操作，如果<code>hash</code>值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在<code>get</code>时会出现死循环，所以<code>HashMap</code>是线程不安全的。 </p>
<p>​    <code>HashTable</code>，它是线程安全的，它在所有涉及到多线程操作的都加上了<code>synchronized</code>关键字来锁住整个<code>table</code>，这就意味着所有的线程都在竞争一把锁，在多线程的环境下，它是安全的，但是无疑是效率低下的。 </p>
<p>​    其实<code>HashTable</code>有很多的优化空间，锁住整个<code>table</code>这么粗暴的方法可以变相的柔和点，比如在多线程的环境下，对不同的数据集进行操作时其实根本就不需要去竞争一个锁，因为他们不同<code>hash</code>值，不会因为<code>rehash</code>造成线程不安全，所以互不影响，这就是锁分离技术，将锁的粒度降低，利用多个锁来控制多个小的<code>table</code>，多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是<code>ConcurrentHashMap</code>JDK1.7版本的核心思想。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMapExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="comment">// 线程安全，输出结果准确并一致</span></span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, map.size());</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        map.put(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h5><p>​    TreeMap -&gt; ConcurrentSkipListMap，内部使用<code></code>SkipList`结构实现的。跳表是一个链表，但是通过使用“跳跃式”查找的方式使得插入、读取数据时复杂度变成了O（log n）。</p>
<p>​    跳表（SkipList）：使用“空间换时间”的算法，令链表的每个结点不仅记录next结点位置，还可以按照level层级分别记录后继第level个结点。 </p>
<blockquote>
<p>参考文章：<a href="http://www.cnblogs.com/ygj0930/p/6543901.html" target="_blank" rel="noopener">Java并发容器——ConcurrentSkipListMap和ConcurrentHashMap</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSkipListMapExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, map.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        map.put(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="concurrentHashMap与ConcurrentSkipListMap性能测试"><a href="#concurrentHashMap与ConcurrentSkipListMap性能测试" class="headerlink" title="concurrentHashMap与ConcurrentSkipListMap性能测试"></a>concurrentHashMap与ConcurrentSkipListMap性能测试</h5><p>​    内容引用于<a href="https://blog.csdn.net/vernonzheng/article/details/8244984" target="_blank" rel="noopener">Java多线程（四）之ConcurrentSkipListMap深入分析 </a></p>
<p>​    在4线程1.6万数据的条件下，<code>ConcurrentHashMap</code> 存取速度是<code>ConcurrentSkipListMap</code> 的4倍左右。 </p>
<p>​    但<code>ConcurrentSkipListMap</code>有几个<code>ConcurrentHashMap</code>不能比拟的<strong>优点</strong>：</p>
<ol>
<li><code>ConcurrentSkipListMap</code> 的key是有序的，而<code>ConcurrentHashMap</code>是做不到的</li>
<li><p><code>ConcurrentSkipListMap</code> 支持更高的并发。<code>ConcurrentSkipListMap</code>的存取时间是<code>log（N）</code>，和线程数几乎无关。也就是说在数据量一定的情况下，并发的线程越多，<code>ConcurrentSkipListMap</code>越能体现出他的优势。 </p>
<pre><code>在非多线程情况下，尽量使用`TreeMap`，此外，对于并发性较低的程序，可以使用`Collections`工具所提供的方法`synchronizedSortMap`，它是将`TreeMap`进行包装。对于高并发场景下，应使用`ConcurrentSkipListMap`提供更高的并发度。并且，如果在多线程环境下，需要对`Map`的键值进行排序时，也要尽量使用`ConcurrentSkipListMap`
</code></pre></li>
</ol>
<h5 id="J-U-C-内容概览"><a href="#J-U-C-内容概览" class="headerlink" title="J.U.C 内容概览"></a>J.U.C 内容概览</h5><p><img src="images/j.u.c.jpg" alt=""></p>
<h4 id="安全共享策略总结"><a href="#安全共享策略总结" class="headerlink" title="安全共享策略总结"></a>安全共享策略总结</h4><p>​    以下策略是通过线程安全策略中的不可变对象、线程封闭、同步容器以及并发容器相关知识总结而得：</p>
<ol>
<li>线程限制：一个被线程限制的对象，由线程独占，并且只能被占有它的线程修改</li>
<li>共享只读：一个共享只读的对象，在没有额外同步的情况下，可以被多个线程并发访问，但是任何线程都不能修改它</li>
<li>线程安全对象：一个线程安全的对象或容器，在内部通过同步机制来保证线程安全，所以其他线程无需额外的同步就可以通过公共接口随意访问它</li>
<li>被守护对象：被守护对象只能通过获取特定的锁来访问</li>
</ol>

      
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  <article class="index-post card" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/19/Nexus搭建Maven私服及使用教程/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
        <meta itemprop="name" content="龙门小左">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="程序猿的日常">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2018/06/19/Nexus搭建Maven私服及使用教程/" itemprop="url"></a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2018-06-19T10:21:37+08:00">2018-06-19 10:21:37</time></span>
        </span>
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <p>[TOC]</p>
<h1 id="Nexus-3-x搭建Maven私服及使用教程"><a href="#Nexus-3-x搭建Maven私服及使用教程" class="headerlink" title="Nexus 3.x搭建Maven私服及使用教程"></a>Nexus 3.x搭建Maven私服及使用教程</h1><table>
<thead>
<tr>
<th style="text-align:center">版本</th>
<th style="text-align:center">备注</th>
<th style="text-align:center">编制人</th>
<th style="text-align:center">日期</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">V1.0</td>
<td style="text-align:center">Nexus 3.x搭建Maven私服及使用</td>
<td style="text-align:center">陈权栋</td>
<td style="text-align:center">2017-07-07</td>
</tr>
</tbody>
</table>
<p>广州图灵科技有限公司</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一般maven项目开发，我们所需的所有构件都需要通过maven的中央仓库和第三方的Maven仓库下载到本地。而一个团队中的所有人都重复地从maven仓库下载构件无疑加大了仓库的负载和浪费了外网带宽，如果网速慢的话，还会影响项目的进程。很多情况下，项目的开发都是在内网进行的，连接不到maven仓库怎么办呢？开发的公共构件怎么让其它项目使用？这个时候我们都会选择为自己的团队搭建属于自己的maven私服，这样既节省了网络带宽也会加速项目搭建的进程，当然前提条件就是你的私服中拥有项目所需的所有构件。</p>
<p>这里的私服是指私有服务器，是架设在局域网的一种特殊的远程仓库，目的是代理远程仓库及部署第三方构件。有了私服之后，当 Maven 需要下载构件时，直接请求私服，私服上存在则下载到本地仓库；否则，私服请求外部的远程仓库，将构件下载到私服，再提供给本地仓库下载（见下图）。</p>
<p>搭建Maven私服，我们选择的是Nexus Repository OSS。它是一个强大的Maven仓库管理器，它极大地简化了本地内部仓库的维护和外部仓库的访问，最重要的是，它是免费开源的！</p>
<p><img src="img/私服示例图.png" alt="无效" title="私服示例图"></p>
<blockquote>
<p>注：</p>
</blockquote>
<blockquote>
<p>图中的远程仓库处于外网，而私服和本地仓库处于内网</p>
</blockquote>
<h2 id="搭建Maven私服前的说明或准备"><a href="#搭建Maven私服前的说明或准备" class="headerlink" title="搭建Maven私服前的说明或准备"></a>搭建Maven私服前的说明或准备</h2><ul>
<li><p>搭建操作系统为Ubuntu 16.04，Windows也有安装包，但没有尝试过</p>
</li>
<li><p>Apache Maven版本为3.3.9，需要提前安装好，安装过程这里不做讲解，有需要自行谷歌或百度</p>
</li>
<li><p>Intellij IDEA版本为2017.1.3，用于项目发布构建到私服上的测试</p>
</li>
</ul>
<h2 id="搭建Maven私服步骤"><a href="#搭建Maven私服步骤" class="headerlink" title="搭建Maven私服步骤"></a>搭建Maven私服步骤</h2><h3 id="1、到官网下载Nexus安装包"><a href="#1、到官网下载Nexus安装包" class="headerlink" title="1、到官网下载Nexus安装包"></a>1、到官网下载Nexus安装包</h3><ul>
<li><p>Nexus Repository OSS是免费开源的，我们这里下载与操作系统相对应的最新版<code>Nexus Repository Manager OSS 3.x - Unix</code></p>
</li>
<li><p>其下载链接为：<a href="https://www.sonatype.com/download-oss-sonatype" target="_blank" rel="noopener">https://www.sonatype.com/download-oss-sonatype</a> ，该链接可能需要翻墙，打开得比较慢</p>
</li>
</ul>
<h3 id="2、解压安装Nexus"><a href="#2、解压安装Nexus" class="headerlink" title="2、解压安装Nexus"></a>2、解压安装Nexus</h3><ul>
<li><p>将下载好的安装包拷贝到要解压的目录下</p>
</li>
<li><p>然后在终端进入安装包所在的目录，使用命令<code>tar -zxvf ./nexus-3.3.2-02-unix.tar.gz</code>进行解压</p>
</li>
<li><p>解压完后，通过<code>cd nexus</code>命令进入目录，执行<code>ls</code>命令可看到如下图的文件：</p>
</li>
</ul>
<p><img src="img/解压文件.png" alt="无效" title="解压文件"></p>
<blockquote>
<p>注：</p>
</blockquote>
<blockquote>
<p>其中，nexus-3.3.2-02目录中存放启动和关闭文件，以及配置文件，而sonatype-work一般存放数据文件，比如构件的数据</p>
</blockquote>
<h3 id="3、启动Nexus"><a href="#3、启动Nexus" class="headerlink" title="3、启动Nexus"></a>3、启动Nexus</h3><ul>
<li><p>在上一步的终端，通过<code>cd nexus-3.3.2-02/bin</code>进入启动文件目录</p>
</li>
<li><p>然后，通过命令<code>./nexus start</code>或<code>./nexus run</code>启动Nexus，其中<code>start</code>是后台启动，而<code>run</code>不是，会在终端控制台打印出启动信息</p>
</li>
<li><p>启动完成后，打开浏览器，访问<a href="http://localhost:8081/" target="_blank" rel="noopener">http://localhost:8081/</a> 即可看到运行的Nexus，如下图：</p>
</li>
</ul>
<p><img src="img/运行成功.png" alt="无效" title="运行成功"></p>
<h2 id="Nexus使用"><a href="#Nexus使用" class="headerlink" title="Nexus使用"></a>Nexus使用</h2><h3 id="1、说明"><a href="#1、说明" class="headerlink" title="1、说明"></a>1、说明</h3><ul>
<li><p>仓库类型说明</p>
<ul>
<li><p>group(仓库组类型)：又叫组仓库，用于方便开发人员自己设定仓库</p>
</li>
<li><p>hosted(宿主类型)：内部项目的发布仓库（内部开发人员，发布上去存放的仓库），包括为<code>release(发行版)</code>仓库和<code>snapshot(调试版)</code>仓库，创建时最好选择允许重新部署</p>
</li>
<li><p>proxy(代理类型)：从远程中央仓库中寻找数据的仓库</p>
</li>
<li><p>virtual(虚拟类型)：虚拟仓库（这个基本用不到，重点关注上面三个仓库的使用）</p>
</li>
</ul>
</li>
<li><p>自带仓库(组)说明</p>
<ul>
<li><p>maven-central：proxy类型仓库，是Maven中央库，默认从<a href="https://repo1.maven.org/maven2/" target="_blank" rel="noopener">https://repo1.maven.org/maven2/</a> 拉取jar 包</p>
</li>
<li><p>maven-releases：hosted类型仓库，存放私库发行版jar 包</p>
</li>
<li><p>maven-snapshots：hosted类型仓库，存放私库快照（调试版本）jar 包</p>
</li>
<li><p>maven-public：仓库组类型，把上面三个仓库组合在一起对外提供服务，默认包括<code>maven-central</code>、<code>maven-releases</code>和<code>maven-snapshots</code>三个仓库</p>
</li>
</ul>
</li>
<li><p>理解图示：</p>
</li>
</ul>
<p><img src="img/理解图示.png" alt="无效" title="理解图示"></p>
<h3 id="2、登录"><a href="#2、登录" class="headerlink" title="2、登录"></a>2、登录</h3><ul>
<li>点击右上交的<code>Sign in</code>，输入账号密码（初始化账号为<code>admin</code>，密码为<code>admin123</code>）进行登录，如下图所示：</li>
</ul>
<p><img src="img/登录.png" alt="无效" title="登录"></p>
<blockquote>
<p>注：</p>
</blockquote>
<blockquote>
<p>登录后建议立即修改密码，点击右上角的<code>admin</code>即可进行修改，这里不做详述</p>
</blockquote>
<h3 id="3、添加用户账号"><a href="#3、添加用户账号" class="headerlink" title="3、添加用户账号"></a>3、添加用户账号</h3><ul>
<li>Nexus允许添加用户账号，然后，对不同的用户进行不同权限的授权，如下图所示：</li>
</ul>
<p><img src="img/添加用户.png" alt="无效" title="添加用户"></p>
<blockquote>
<p>注：</p>
</blockquote>
<blockquote>
<p>所有字段都是必填的，ID将作为用户名</p>
</blockquote>
<blockquote>
<p>Granted为新建账号进行权限授权，<code>nx-admin</code>为管理员角色，里面配置了最大的权限，不可修改，而<code>nx-anonymous</code>为匿名用户角色，不需要登录，只能查看和下载构件，权限可由管理员进行修改</p>
</blockquote>
<blockquote>
<p>关于权限和角色配置模块，这里就不作介绍了，有兴趣可以查看页面左边的<code>Privileges</code>和<code>Roles</code>菜单</p>
</blockquote>
<h3 id="4、将Maven项目CommonUtils发布到Maven私服"><a href="#4、将Maven项目CommonUtils发布到Maven私服" class="headerlink" title="4、将Maven项目CommonUtils发布到Maven私服"></a>4、将Maven项目CommonUtils发布到Maven私服</h3><ul>
<li>在Maven的配置文件setting.xml的<code>&lt;servers&gt;&lt;/servers&gt;</code>标签中间添加以下配置：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">password</span>&gt;</span>******<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：</p>
</blockquote>
<blockquote>
<p>其中的id可以任意取，password为Nexus的<code>admin</code>用户的密码，默认为admin123</p>
</blockquote>
<ul>
<li>用Intellij IDEA打开CommonUtils项目，并在pom.xml文件中添加下面配置:</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Release<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.20:8081/repository/maven-releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Snapshot<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.20:8081/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：</p>
</blockquote>
<blockquote>
<p><code>&lt;repository&gt;&lt;/repository&gt;</code>中配置release仓库，<code>&lt;snapshotRepository&gt;&lt;/snapshotRepository&gt;</code>中配置snapshot仓库</p>
</blockquote>
<blockquote>
<p>其中的id就是Maven的setting.xml文件的server的id，用于发布构件到Maven私服时的认证</p>
</blockquote>
<blockquote>
<p>name可以任意取，url则分别对应release仓库和snapshot仓库的地址，url中的IP就是Maven私服的IP地址</p>
</blockquote>
<blockquote>
<p>发布构件到Maven私服时，会根据pom.xml中的<code>&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</code>是否有<code>SNAPSHOT</code>选择发布到哪个仓库中，有则发布到snapshot仓库，否则发布到release仓库</p>
</blockquote>
<ul>
<li>打开Intellij IDEA的Maven Projects，双击<code>deploy</code>进行发布构件到Maven私服，如下图所示:</li>
</ul>
<p><img src="img/发布构件.png" alt="无效" title="发布构件"></p>
<blockquote>
<p>注：</p>
</blockquote>
<blockquote>
<p>发布时，如果pom.xml中的<code>&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</code>有<code>SNAPSHOT</code>则发布到snapshot仓库，否则发布到release仓库</p>
</blockquote>
<h3 id="5、发布第三方jar包-以发布支付宝依赖为例子"><a href="#5、发布第三方jar包-以发布支付宝依赖为例子" class="headerlink" title="5、发布第三方jar包(以发布支付宝依赖为例子)"></a>5、发布第三方jar包(以发布支付宝依赖为例子)</h3><ul>
<li>调出终端，执行下面命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mvn deploy:deploy-file </span><br><span class="line">  -DgroupId=com.alipay</span><br><span class="line">  -DartifactId=api</span><br><span class="line">  -Dversion=1.0</span><br><span class="line">  -Dpackaging=jar </span><br><span class="line">  -Dfile=/home/quandong/alipay.jar</span><br><span class="line">  -Durl=http://localhost:8081/repository/maven-releases/</span><br><span class="line">  -DrepositoryId=nexus</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注:</p>
</blockquote>
<blockquote>
<p>执行命令前确定安装了Maven</p>
</blockquote>
<blockquote>
<p><code>DgroupId</code>构件的组名</p>
</blockquote>
<blockquote>
<p><code>DartifactId</code>构件名称</p>
</blockquote>
<blockquote>
<p><code>Dversion</code>构件版本号</p>
</blockquote>
<blockquote>
<p><code>Dpackaging</code>构件类型，一般为jar</p>
</blockquote>
<blockquote>
<p><code>Dfile</code>构件所在本地路径</p>
</blockquote>
<blockquote>
<p><code>Durl</code>存放构件的仓库url</p>
</blockquote>
<blockquote>
<p><code>DrepositoryId</code>发布构件时的认证身份，之前在Maven的setting.xml文件中配置的server的id</p>
</blockquote>
<h3 id="6、发布结果"><a href="#6、发布结果" class="headerlink" title="6、发布结果"></a>6、发布结果</h3><ul>
<li>到Maven私服查看发布的构件，如下图所示:</li>
</ul>
<p><img src="img/发布结果.png" alt="无效" title="发布结果"></p>
<h3 id="7、其他项目引用发布的CommonUtils构件-引用api构件也一样"><a href="#7、其他项目引用发布的CommonUtils构件-引用api构件也一样" class="headerlink" title="7、其他项目引用发布的CommonUtils构件(引用api构件也一样)"></a>7、其他项目引用发布的CommonUtils构件(引用api构件也一样)</h3><ul>
<li>在其他项目的pom.xml文件中引入下面的配置，使得项目可以从Maven私服中下载CommonUtils构件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>maven-public<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.20:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.turingdi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commonutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：</p>
</blockquote>
<blockquote>
<p>其中的url是仓库组的url，仓库组中包括了代理仓库、宿主发行版仓库和宿主调试版仓库</p>
</blockquote>
<blockquote>
<p>保存后，项目会自动从Maven私服中下载CommonUtils构件</p>
</blockquote>
<blockquote>
<p><code>dependency</code>的<code>groupId</code>、<code>artifactId</code>和<code>version</code>要和CommonUtils项目的pom.xml文件配置一样，忘记了可以在Nexus上面的对应构件中查看</p>
</blockquote>
<p><strong>至此，Nexus搭建Maven私服就完成了</strong></p>
<p><strong>欢迎阅读，并希望能指出其中的失误之处，感谢!</strong></p>

      
    </main>
    <footer class="post-footer">
      
    </footer>
  </article>
  
  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a>
  </nav>
  
  
</div>

          </div>
          
          
          
<aside class="sidebar" id="sidebar" style="background: url(/images/sidebar_background.png);">
  
  <div class="search">
    <div class="form-group">
      <i class="fas fa-search"></i><input type="search" id="search-input" name="q" results="0" placeholder="Search" class="form-control"/>
    </div>
  </div>
  <div class="search-result-box" id="search-result"></div>
  
  
<div class="info sidebar-item" id="info">
  
  <img class="author-avatar" src="/images/avatar.png" alt="龙门小左">
  
  <h1 class="author-name">龙门小左</h1>
  <h2 class="author-description"> </h2>
  <div class="site-count">
    
    <div class="archives-count">
      <div class="site-count-title">Archives</div>
      <div><a href="/archives/">15</a></div>
    </div>
    
    
    
  </div>
  
  <div class="rss">
    <a class="rss-link button sidebar-item" href="/atom.xml"><i class="fas fa-rss"></i>RSS</a>
  </div>
  
</div>


  <div class="sidebar-sticky">
    
    
    
<hr>
<div class="social-link sidebar-item">
  <div><i class="far fa-address-card"></i>Social Links</p></div>
  <ul>
    
    <li><i class="fas fa-envelope"></i><a href="mailto:youremail@youremailhost" target="_blank">E-Mail</a></li>
    
    <li><i class="fab fa-github"></i><a href="https://github.com/" target="_blank">GitHub</a></li>
    
    <li><i class="fab fa-weibo"></i><a href="https://weibo.com/" target="_blank">Weibo</a></li>
    
  </ul>
</div>


    
    
    
<hr>
<div class="blogroll sidebar-item">
  <div><i class="fas fa-link"></i>Blogroll</div>
  <ul>
    
    <li><a href="https://github.com/" target="_blank">GitHub</a></li>
    
    <li><a href="https://developer.mozilla.org/" target="_blank">MDN</a></li>
    
    <li><a href="https://mozilla.github.io/nunjucks/" target="_blank">Nunjucks</a></li>
    
  </ul>
</div>


    
  </div>
</aside>


          
        </div>
      </div>
    </main>
    
<footer id="footer" class="footer" style="background: #33363b;">
  <div class="container">
    <div class="back-to-top">
      <a id="back-to-top"><i class="fas fa-angle-double-up"></i></a>
    </div>
    <div class="footer-container">
      <div class="footer-left">
        <div class="copyright">
          <span class="author">龙门小左</span><span class="year"><i class="far fa-copyright"></i>2018</span>
        </div>
        
        
<div class="busuanzi">
  <span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i><span id="busuanzi_value_site_pv"></span></span><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i><span id="busuanzi_value_site_uv"></span></span><span id="busuanzi_container_page_pv"><i class="far fa-file-alt"></i><span id="busuanzi_value_page_pv"></span></span>
</div>


        
      </div>
      <div class="footer-right">
        <div class="custom-info">
          
          托管于<i class="fab fa-github-alt"></i><a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
          
        </div>
        <div class="powered-by">
          Proudly Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> | Theme is <a href="https://github.com/AlynxZhou/hexo-theme-aria/" target="_blank">ARIA</a>
        </div>
      </div>
    </div>
  </div>
</footer>


  </body>
</html>
